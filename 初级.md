# 一、SpringBoot入门

## 1、SpringBoot简介

简化Spring应用开发的一个框架；

整个Spring技术栈的一个大整合；

J2EE开发的一站式解决方案；

## 2、微服务

微服务：架构风格

一个应用应该是一组小型服务：可以通过HTTP的方式进行互通：



每一个功能元素都是一个可独立替换和独立升级的软件单元：



[微服务原文](https://martinfowler.com/articles/microservices.html)

[翻译](https://blog.csdn.net/weixin_42236165/article/details/92979025)

## 3、环境准备

JDK1.8

IDEA2017

## 4、SpringBoot HelloWorld

一个功能：

		浏览器发送hello请求，服务器接受请求并处理，相应Hello World字符串。



### 1、创建一个maven工程

### 2、导入Spring Boot相关 的依赖

[项目](E:\workspace\workspace-springboot\1\springboot01helloworld)

```xml
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>2.2.2.RELEASE</version>
</parent>
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
     </dependency>
</dependencies>
```

### 3、编写一个主程序：启动Spring Boot应用

```java
/**
 * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用
 */
@SpringBootApplication
public class HelloWorldMainApplication {

    public static void main(String[] args) {
        //Spring应用启动起来
        SpringApplication.run(HelloWorldMainApplication.class,args);
    }
}
```

### 4、编写相关的Controller、Service

```java
@Controller
public class HelloController {

    @ResponseBody
    @RequestMapping("/hello")
    public String hello(){
        return "hello World";
    }
}
```

### 5、运行主程序测试

### 6、简化部署

```xml
<!-- 这个插件，可以将应用打包成一个可执行的jar包 -->
<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
        </plugin>
    </plugins>
</build>
```

将这个应用打成jar包，直接使用 java -jar的命令进行执行；

## 5、HelloWorld探究

### 1、pom文件

#### 1、父项目

```xml
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>2.2.2.RELEASE</version>
</parent>
    
他的父项目是
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-dependencies</artifactId>
    <version>2.2.2.RELEASE</version>
    <relativePath>../../spring-boot-dependencies</relativePath>
</parent>
他来真正管理Spring Boot应用里面的所有依赖版本
```

Spring Boot的版本仲裁中心：

		以后我们导入依赖默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要声明版本号）

#### 2、启动器

```xml
<dependency>
     <groupId>org.springframework.boot</groupId>
     <artifactId>spring-boot-starter</artifactId>
</dependency>
```

#### spring-boot-starter-web：

spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件；



Spring Boot将所有的功能场景都抽取出来，做成一个个的starter（启动器），只需要在项目里面导入这些starter相关场景的所有依赖都会导入进来，要用什么功能就导入什么场景的启动器

### 2、主程序类，主入口

```java
/**
 * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用
 */
@SpringBootApplication
public class HelloWorldMainApplication {

    public static void main(String[] args) {
        //Spring应用启动起来
        SpringApplication.run(HelloWorldMainApplication.class,args);
    }
}
```

@SpringBootApplication：Spring Boot应用标注在某个类上说明这个是Spring Boot的主配置类，Spring Boot就应该执行这个类的main方法来启动Spring Boot应用。

```java
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(
    excludeFilters = {@Filter(
    type = FilterType.CUSTOM,
    classes = {TypeExcludeFilter.class}
), @Filter(
    type = FilterType.CUSTOM,
    classes = {AutoConfigurationExcludeFilter.class}
)}
)
public @interface SpringBootApplication {
```

- **@SpringBootConfiguration**：Spring Boot的配置类：

  标注在某个类上，表示这是一个Spring的配置类；

  		@**Configuration**：配置类上标注这个注解；
		
  		配置类 ------- 配置文件；配置类也是容器中的一个组件：@Component

- **@EnableAutoConfiguration**：开启自动配置功能：

  		以前我们需要配置的东西，Spring Boot帮我们自动配置；**@EnableAutoConfiguration**告诉Spring Boot开启自动配置功能；这样自动配置功能才能生效。

  ```java
  @AutoConfigurationPackage
  @Import({AutoConfigurationImportSelector.class})
  public @interface EnableAutoConfiguration {
  ```

  - **@AutoConfigurationPackage**：自动配置包

    - @import(AutoConfigurationPackages.Registrar.class);

      	Spring的底层注解@Import，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Packages.Registrar.class;

        	==将主配置类(@SpringBootApplication标注的类)的所在包及下面所有子包里面的所有组件扫描到Spring容器；==

  - **@Import({AutoConfigurationImportSelector.class})**：给容器中导入组件

    - **AutoConfigurationImportSelector**：导入哪些组件的选择器

      将所有需要导入的组件以全类名的方式返回，这些组件就会被添加到容器中

      会给容器中导入非常多的自动配置类(xxxAutoConfiguration)：就是给容器中导入这个场景需要的所有组件，并配置好这些组件。

      ![image-20200102171739205](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20200102171739205.png)

      有了自动配置类，免去了我们手动编写配置注入功能组件等的工作。

      	SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader);

      ==Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作==，以前我们需要自己配置的东西，自动配置类都帮我们配置了。

       

      J2EE的整合解决方案和自动配置都在spring-boot-autoconfigure-2.2.2.RELEASE.jar

```
@SpringBootConfiguration：	SpringBoot的配置
	@Configuration：		Spring配置类
	@Component：			说明这也是一个spring的组件
	
@EnableAutoConfiguration：	自动配置
	@AutoConfigurationPackage：		自动装配包
		@Import(AutoConfigurationPackages.Registrar.class)：		自动配置"包注册"
	@Import(AutoConfigurationImportSelector.class)：			自动配置导入选择
```





## 6、使用Spring Initializer快速创建Spring Boot项目

IDEA都支持使用Spring的项目创建向导快速创建一个Spring Boot项目；

选择我们需要的模块，向导会联网创建Spring Boot项目；

默认生成的Spring Boot项目：

* 主程序已经生成好了，我们只需要我们自己的逻辑
* resource文件夹中目录结构
  * static：保存所有的静态资源：js、css、images
  * template：保存所有的模板页面（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面），可以使用模板引擎（freemarker、thymeleaf）
  * application.properties：Spring Boot的默认配置文件，可以修改一些默认设置。







# 二、配置文件

[SpringBoot中定义好的配置](https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/html/appendix-application-properties.html#common-application-properties)

## 1、配置文件

Spring Boot使用一个全局的配置文件，配置文件名是固定的

* application.properties
* application.yml



配置文件的作用：修改Spring Boot自动配置的默认值，Spring Boot在底层都给我们自动配置好



YAML（YAML Ain't Markup Language）

标记语言：

		以前的配置文件，大多都使用的是 xxx.xml 文件
	
		YAML：以数据为中心，比json、xml等更适合做配置文件

yaml：配置例子

```yaml
server:
  port: 8081
```

xml:

```xml
<server>
    <port>8081</port>
</server>
```



## 2、YAML语法

### 1、基本语法

k:(空格)v：表示一对键值对（空格必须有）

以空格的缩进来控制层级关系：只要是左对齐的一列数据，都是同一个层级的

```yaml
server:
	port: 8081
```

属性和值也是大小写敏感



### 2、值的写法

#### 字面量：普通的值（数字、字符串、布尔）

	k: v 字面直接来写
	
			字符串默认不用加上单引号或者双引号。
	
			""（双引号）：不会转义字符串里面的特殊字符，特殊字符会作为本身想表示的意思。
	
									name: "zhangsan \n lisi"	输出：zhangsan 换行 lisi
	
			‘’（单引号）：会转义特殊字符，特殊字符最终只是一个普通的字符串数据
	
									name: 'zhangsan \n lisi'	  输出：zhangsan \n lisi

#### 对象、Map（属性和值）（键值对）

k: v：在下一行来写对象的属性和值的关系，注意缩进

		对象还是k: v的方式

```yaml
friends:
	lastName: zhangsan
	age:20
```

行内写法

```yaml
friends: {lastName: zhangsan,age: 18}
```



#### 数组（List、Set）

用- 值表示数组中的一个元素

```yaml
pets:
	- dog
	- cat
	- pig
```

行内写法

```yaml
pets: [dog,cat,pig]
```





## 3、配置文件值注入

**注：properties配置文件在idea中默认utf-8可能会出现乱码**

```properties
#idea使用的是utf-8
# 配置person的值
person.lastName=张三
person.age=10
person.birth=2017/12/15
person.boss=false
person.maps.k1=v1
person.maps.k2=v2
person.lists=a,b,c
person.dog.name=dog
person.dog.age=15
```

![image-20200103085649331](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20200103085649331.png)

### 1、@ConfigurationProperties

配置文件

```yaml
person:
  lastName: zhangsan
  age: 18
  boss: false
  birth: 2017/12/12
  maps: {k1: v1,k2: v2}
  lists:
  - lisi
  - wangwu
  - zhaoliu
  dog:
    name: 旺财
    age: 2
```

javaBean

```java
/**
 * 将配置文件中配置的每一个属性的值，映射到这个组件中
 * @ConfigurationProperties：道速Spring Boot将本类中的所有属性和配置文件中相关的配置进行绑定
 *      prefix = "person" 配置文件中哪个下面的所有属性进行一一映射
 *
 *  只有这个组件是容器中的组件，才能使用容器提供的@ConfigurationProperties功能
 *
 */
@Component
@ConfigurationProperties(prefix = "person")
public class Person {

    private String lastName;
    private Integer age;
    private Boolean boss;
    private Date birth;

    private Map<String,Object> maps;
    private List<Object> lists;
    private Dog dog;
    
```



我们可以导入配置文件处理器，以后编写配置就有提示了

```xml
<!--导入配置文件处理器，配置文件进行绑定就会有提示-->
<dependency>
     <groupId>org.springframework.boot</groupId>
     <artifactId>spring-boot-configuration-processor</artifactId>
     <optional>true</optional>
</dependency>
```



### 2、@Value

```java
@Component
public class Person {

    @Value("${person.lastName}")
    private String lastName;
    @Value("#{11*2}")
    private Integer age;
    @Value("true")
    private Boolean boss;
    @Value("2020/2/25")
    private Date birth;

    private Map<String,Object> maps;
    private List<Object> lists;
    private Dog dog;
```



**@Value获取值和@ConfigurationProperties获取值比较**

|                      | @ConfigurationProperties | @Value     |
| -------------------- | ------------------------ | ---------- |
| 功能                 | 批量注入配置文件中的属性 | 一个个指定 |
| 松散绑定（松散语法） | 支持                     | 不支持     |
| SpEL                 | 不支持                   | 支持       |
| JSR303数据校验       | 支持                     | 不支持     |
| 复杂类型封装         | 支持                     | 不支持     |

配置文件yml还是properties他们都能获取到值

如果说，我们只是在某个业务逻辑中需要获取一下配置文件的值，用@Value

如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties



### 3、@PropertySource

**@PropertySource**：加载指定的配置文件

```java
/**
 * 将配置文件中配置的每一个属性的值，映射到这个组件中
 * @ConfigurationProperties：道速Spring Boot将本类中的所有属性和配置文件中相关的配置进行绑定
 *      prefix = "person" 配置文件中哪个下面的所有属性进行一一映射,默认从全局变量中获取值
 *
 *  只有这个组件是容器中的组件，才能使用容器提供的@ConfigurationProperties功能
 *
 */
@PropertySource(value = {"classpath:person.properties"})
@Component
@ConfigurationProperties(prefix = "person")
public class Person {

    private String lastName;
    private Integer age;
    private Boolean boss;
    private Date birth;

    private Map<String,Object> maps;
    private List<Object> lists;
    private Dog dog;
```

```properties
person.lastName=张三
person.age=10
person.birth=2017/12/15
person.boss=false
person.maps.k1=v1
person.maps.k2=v2
person.lists=a,b,c
person.dog.name=dog
person.dog.age=15
```



### 4、@Validated

**对配置文件注入值数据校验**

```java
@Component
@ConfigurationProperties(prefix = "person")
@Validated		//数据校验
public class Person {

    @Email		//邮箱格式
    private String lastName;
    @Null		//元素必须为null
    private Integer age;
    private Boolean boss;
    private Date birth;

    private Map<String,Object> maps;
    private List<Object> lists;
    private Dog dog;
```

![img](https://upload-images.jianshu.io/upload_images/3145530-8ae74d19e6c65b4c?imageMogr2/auto-orient/strip|imageView2/2/w/654/format/webp)

### 5、@ImportResource

**@ImportResource**：导入Spring的配置文件，让配置文件里面的内容生效

Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别

想让Spring的配置文件生效，加载进来：@ImportResource标注在配置类上

```java
@SpringBootApplication//导入Spring的配置文件让其生效
@ImportResource(locations = "classpath:bean.xml")
public class SpringBoot02ConfigApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringBoot02ConfigApplication.class, args);
    }
}
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="helloService" class="com.atguigu.springboot.service.HelloService"></bean>
</beans>
```



Spring Boot推荐给容器中添加组件的方式，推荐使用全注解的方式

1、配置类---------Spring配置文件

2、使用@Bean给容器中添加组件

```java
/**
 * @Configuration：指明当前类是一个配置类，就是来替代之前的Spring配置文件
 *
 * 在配置文件中使用<bean></bean>标签添加组件
 */
@Configuration
public class MyAppConfig {

    //将方法的返回值添加到容器中，容器中这个组件默认的id就是方法名
    @Bean
    public HelloService helloService(){
        System.out.println("给容器中添加组件了");
        return new HelloService();
    }
}
```







## 4、配置文件占位符

### 1、随机数

```java
${random.int}、${random.long}、${random.value}
```

### 2、获取之前配置的值

占位符也可以获取之前配置的值，如果没有的话，使用配置的默认值

```properties
person.lastName=张三${random.uuid}
person.age=${random.int}
person.birth=2017/12/15
person.boss=false
person.maps.k1=v1
person.maps.k2=v2
person.lists=a,b,c
#person.hello=HelloWorld
person.dog.name=${person.hello:hello}_dog}
person.dog.age=15
```





## 5、Profile

### 1、多Profile文件

我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml

默认使用主配置文件

### 2、yaml支持多文档块方式

```yaml
server:
  port: 8081
spring:
  profiles:
    active: prod

---
server:
  port: 8082
spring:
  profiles: dev

---
server:
  port: 8083
spring:
  profiles: prod
```



### 3、激活指定profile

1、在配置文件中指定 spring.profiles.active=dev

2、命令行：

		java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar --spring.profiles.active=dev
	
		可以在测试的时候，配置传入命令行参数

3、虚拟机参数：

		-Dspring.profiles.active=dev





## 6、配置文件加载位置

Spring Boot启动会扫描以下位置的 application.properties 或者application.yaml 文件作为Spring Boot的默认配置文件

-file:./config/

-file:./

-classpath:/config/

-classpath:/

优先级由高到低，高优先级的配置会覆盖低优先级的配置。

Spring Boot会从这四个位置全部加载主配置文件，互补配置。



==我们还可以通过spring.config.location来改变默认的配置文件位置==

**通过打包好之后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置，指定配置文件和默认加载的这些配置文件共同起作用形成互补配置。**

java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar --spring.config.location = G:/application.properties





## 7、外部配置加载顺序

Spring Boot也可以从以下位置加载配置：按照优先级从高到低，高优先级的覆盖低优先级的，所有的配置会形成互补配置

1、命令行参数

		java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar -server.port=8087 --server.context-path:/abc
	
		多个配置用空格分开

2、来自java:comp/env的NDI属性

3、java系统属性（System.getProperties()）

4、操作系统环境变量

5、RandomValuePropertySource配置的random.*属性值



		==**由jar包外向jar包内进行寻找，优先加载带profile**==

6、jar包外部的application-{profile}.properties或application.yml（带spring.profile)配置文件

7、jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件



		**==再来加载不带profile==**

8、jar包外部的application.properties或application.yml(不带spring.profile)配置文件

9、jar包内部的application.properties或application.yml(不带spring.profile)配置文件





10、@Configuration注解类上的@PropertySource

11、通过SpringApplication.setDefaultProperties指定的默认属性





## 8、自动配置原理

[项目](E:\workspace\workspace-springboot\1\spring-boot-02-config-autoconfig)

![image-20200323141153348](F:\Typora\images\image-20200323141153348.png)

![image-20200323141112648](F:\Typora\images\image-20200323141112648.png)

### 1、自动配置原理

可以查看前面的  [@SpringBootApplication注解](###2、主程序类，主入口)

1）Spring Boot启动的时候加载主配置类，开启了自动配置功能， ==@EnableAutoConfiguration==

2）@EnableAutoConfiguration作用：

- 利用 AutoConfigurationImportSelector 给容器中导入一些组件	

- 可以查看 selectImports() 方法的内容：

  ```java
  @Override
  public String[] selectImports(AnnotationMetadata annotationMetadata) {
      if (!isEnabled(annotationMetadata)) {
          return NO_IMPORTS;
      }
      AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader
              .loadMetadata(this.beanClassLoader);
      AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(autoConfigurationMetadata,
              annotationMetadata);
      return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());
  }
  ```

- 其中的 `getAutoConfigurationEntry` 方法中

  ```java
  //获取候选的配置
  List<String> configurations = getCandidateConfigurations(annotationMetadata, attributes);
  ```

  获取候选的配置

  ```java
  protected List<String> getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {
      List<String> configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),
              getBeanClassLoader());
      Assert.notEmpty(configurations, "No auto configuration classes found in META-INF/spring.factories. If you "
              + "are using a custom packaging, make sure that file is correct.");
      return configurations;
  }
  ```

  获取所有的加载配置

  ```java
  public static List<String> loadFactoryNames(Class<?> factoryType, @Nullable ClassLoader classLoader) {
      String factoryTypeName = factoryType.getName();
      return (List)loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList());
  }
  ```

  ```java
  loadSpringFactories()方法中
  
  classLoader.getResources("META-INF/spring.factories")：获取项目资源
  ClassLoader.getSystemResources("META-INF/spring.factories")：获取系统资源
  ```

  在 `spring-boot-autoconfigure-2.2.2.RELEASE.jar` 包下

==**将路径下 META-INF/spring.factories 里面配置的所有 EnableAutoConfiguration 的值加入到了容器中**==

```factories
# Auto Configure
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\
org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\
org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\
org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\
org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\
org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\
org.springframework.boot.autoconfigure.cloud.CloudServiceConnectorsAutoConfiguration,\
org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\
org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\
org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\
org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\
org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\
org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\
org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.elasticsearch.ReactiveRestClientAutoConfiguration,\
org.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.mongo.MongoReactiveDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.mongo.MongoReactiveRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\
org.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration,\
org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\
org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\
org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\
org.springframework.boot.autoconfigure.elasticsearch.rest.RestClientAutoConfiguration,\
org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\
org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\
org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\
org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\
org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\
org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\
org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\
org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration,\
org.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration,\
org.springframework.boot.autoconfigure.influx.InfluxDbAutoConfiguration,\
org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\
org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\
org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\
org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\
org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\
org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\
org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\
org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\
org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\
org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\
org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\
org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\
org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\
org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\
org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\
org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\
org.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration,\
org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\
org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\
org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\
org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\
org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\
org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\
org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\
org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\
org.springframework.boot.autoconfigure.mongo.MongoReactiveAutoConfiguration,\
org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\
org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\
org.springframework.boot.autoconfigure.quartz.QuartzAutoConfiguration,\
org.springframework.boot.autoconfigure.rsocket.RSocketMessagingAutoConfiguration,\
org.springframework.boot.autoconfigure.rsocket.RSocketRequesterAutoConfiguration,\
org.springframework.boot.autoconfigure.rsocket.RSocketServerAutoConfiguration,\
org.springframework.boot.autoconfigure.rsocket.RSocketStrategiesAutoConfiguration,\
org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration,\
org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration,\
org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration,\
org.springframework.boot.autoconfigure.security.reactive.ReactiveSecurityAutoConfiguration,\
org.springframework.boot.autoconfigure.security.reactive.ReactiveUserDetailsServiceAutoConfiguration,\
org.springframework.boot.autoconfigure.security.rsocket.RSocketSecurityAutoConfiguration,\
org.springframework.boot.autoconfigure.security.saml2.Saml2RelyingPartyAutoConfiguration,\
org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\
org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\
org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration,\
org.springframework.boot.autoconfigure.security.oauth2.client.reactive.ReactiveOAuth2ClientAutoConfiguration,\
org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration,\
org.springframework.boot.autoconfigure.security.oauth2.resource.reactive.ReactiveOAuth2ResourceServerAutoConfiguration,\
org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\
org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration,\
org.springframework.boot.autoconfigure.task.TaskSchedulingAutoConfiguration,\
org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\
org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\
org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\
org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\
org.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration,\
org.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration,\
org.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfiguration,\
org.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration,\
org.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration,\
org.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfiguration,\
org.springframework.boot.autoconfigure.web.reactive.function.client.ClientHttpConnectorAutoConfiguration,\
org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration,\
org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\
org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\
org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration,\
org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,\
org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,\
org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\
org.springframework.boot.autoconfigure.websocket.reactive.WebSocketReactiveAutoConfiguration,\
org.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration,\
org.springframework.boot.autoconfigure.websocket.servlet.WebSocketMessagingAutoConfiguration,\
org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration,\
org.springframework.boot.autoconfigure.webservices.client.WebServiceTemplateAutoConfiguration
```

每一个这样的 xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中，用他们来做自动配置。



**注：SpringBoot所有自动配置都是在启动的时候扫描并加载，`spring.factories`所有的自动配置类都在这里，但是不一定生效。而每一个类中有一个核心注解 `@ConditionalOnXXXXX`，只有满足这个注解里面的条件——导入了对应的 `starter` 启动器，有了启动器，我们对应的自动装配就会生效，然后就配置成功！**



3）每一个自动配置类进行自动配置功能：

4）以**HttpEncodingAutoConfiguration(Http编码自动配置)**为例解释自动配置原理

```java
@Configuration(		//这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件
    proxyBeanMethods = false
)
@EnableConfigurationProperties({HttpProperties.class})//启动指定类的ConfigurationProperties功能：将配置文件中对应的值和HttpEncodingProperties绑定起来，并把HttpEncodingProperties加入到ioc容器中
@ConditionalOnWebApplication(
    type = Type.SERVLET
)//Spring底层Condition注解，根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效，判断当前应用是否是web应用，如果是当前配置类生效
@ConditionalOnClass({CharacterEncodingFilter.class})//判断当前项目有没有这个类CharacterEncodingFilter：SpringMVC中进行乱码解决的过滤器
@ConditionalOnProperty(
    prefix = "spring.http.encoding",
    value = {"enabled"},
    matchIfMissing = true
)//判断配置文件中是否存在某个配置spring.http.encoding.enabled,如果不存在，判断也是成立的
//即使配置文件zho9gn不配置spring.http.encoding.enabled=true,也是默认生效的
public class HttpEncodingAutoConfiguration {
    
    //它已经和Spring Boot的配置文件映射了
    private final Encoding properties;
    
    //只有一个有参构造器的情况下，参数的值就会从容器中拿
    public HttpEncodingAutoConfiguration(HttpProperties properties) {
        this.properties = properties.getEncoding();
    }
    
	@Bean//给容器中添加一个组件，这个组件的某些值需要从properties中获取
    @ConditionalOnMissingBean
    public CharacterEncodingFilter characterEncodingFilter() {
        CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();
        filter.setEncoding(this.properties.getCharset().name());
        filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.REQUEST));
        filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.RESPONSE));
        return filter;
    }
```

根据当前不同的条件判断，决定这个配置类是否生效？

一旦这个配置类生效，这个配置类就会给容器中添加各种组件，这些组件的属性是从对应的properties中获取的，这些类里面的每一个属性又是和配置文件绑定的。



5）所有在配置文件中能配置的属性都是在 xxxxProperties 类中封装着，配置文件能配置什么就可以参照某个功能对应的这个属性类

```java
@ConfigurationProperties(
    prefix = "spring.http"
)								//从配置文件中获取指定的值和bean的属性进行绑定
public class HttpProperties {
```





#### 精髓

1）Spring Boot启动会加载大量的自动配置类

2）我们看我们需要的功能有没有Spring Boot默认写好的自动配置类

3）我们再来看这个自动配置类中到底配置类哪些组件（只要我们要用的组件有，我们就不需要了）

4）给容器中自动配置类添加组件的时候，会从properties类中获取某些属性，我们就可以在配置文件中指定这些属性的值



xxxxAutoConfiguration：自动配置类					给容器中添加组件

xxxxProperties：封装配置文件中相关属性



#### 概述

1. SpringBoot在启动的时候，从类路径下 `/META-INF/spring.factories` 获取指定的值
2. 将这些自动配置的类导入容器，自动配置就会生效，帮我们进行自动配置
3. 原先我们需要手动配置的东西，现在SpringBoot帮我们做了
4. 整个JavaEE、解决方案和自动配置的东西都在 `spring-boot-autoconfigure-2.2.2.RELEASE.jar` 这个包下
5. 它会把所有需要导入的组件，以类名的方式返回，这些组件就会被添加到容器
6. 容器中也会存在非常多的 `xxxAutoConfiguration` 的文件（@Bean），就是这些类给容器中导入了这个场景需要的所有组件并配置。@Configuration、JavaConfig
7. 有了自动配置类，免去了手动编写配置文件的工作

![image-20200323203338405](F:\Typora\images\image-20200323203338405.png)

### 2、细节

#### 1、@Condition派生注解

（Spring注解版原生的@Condition作用）

作用：必须是@Condition指定的条件成立，才给容器中添加组件，配置里面的所有内容才生效。



| @Conditional扩展注解            | 作用（判断是否满足当前指定条件）                 |
| ------------------------------- | ------------------------------------------------ |
| @ConditionalOnJava              | 系统的java版本是否符合要求                       |
| @ConditionalOnBean              | 容器中存在指定Bean；                             |
| @ConditionalOnMissingBean       | 容器中不存在指定Bean；                           |
| @ConditionalOnExpression        | 满足SpEL表达式指定                               |
| @ConditionalOnClass             | 系统中有指定的类                                 |
| @ConditionalOnMissingClass      | 系统中没有指定的类                               |
| @ConditionalOnSingleCandidate   | 容器中只有一个指定的Bean，或者这个Bean是首选Bean |
| @ConditionalOnProperty          | 系统中指定的属性是否有指定的值                   |
| @ConditionalOnResource          | 类路径下是否存在指定资源文件                     |
| @ConditionalOnWebApplication    | 当前是web环境                                    |
| @ConditionalOnNotWebApplication | 当前不是web环境                                  |
| @ConditionalOnJndi              | JNDI存在指定项                                   |

**自动配置类必须在一定的条件下才能生效**

我们怎么指定哪些自动配置类生效？

我们可以通过启用 debug=true 属性，来让控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效

```java
Positive matches:（自动配置类启用的）
-----------------

   AopAutoConfiguration matched:
      - @ConditionalOnProperty (spring.aop.auto=true) matched (OnPropertyCondition)

   AopAutoConfiguration.ClassProxyingConfiguration matched:
      - @ConditionalOnMissingClass did not find unwanted class 'org.aspectj.weaver.Advice' (OnClassCondition)
      - @ConditionalOnProperty (spring.aop.proxy-target-class=true) matched (OnPropertyCondition)

   DispatcherServletAutoConfiguration matched:
      - @ConditionalOnClass found required class 'org.springframework.web.servlet.DispatcherServlet' (OnClassCondition)
      - found 'session' scope (OnWebApplicationCondition)
          
          

Negative matches:（没有启动，没有匹配成功的自动配置类）
-----------------

   ActiveMQAutoConfiguration:
      Did not match:
         - @ConditionalOnClass did not find required class 'javax.jms.ConnectionFactory' (OnClassCondition)

   AopAutoConfiguration.AspectJAutoProxyingConfiguration:
      Did not match:
         - @ConditionalOnClass did not find required class 'org.aspectj.weaver.Advice' (OnClassCondition)

```





### 3、SpringApplication run分析

分析该方法主要分两部分：一部分是 `SpringApplication` 的实例化，而是 `run` 方法的执行

#### 1、SpringApplication

这个类主要做了以下四件事情：

1. 推断应用的类型是普通的项目还是web项目
2. 查找并加载所有可用初始化器，设置到 `initializers` 属性中
3. 找出所有的应用程序监听器，设置到 `listeners` 属性中
4. 推断并设置 `main` 方法的定义类，找到运行的主类

**SpringApplication构造器**

```java
public SpringApplication(ResourceLoader resourceLoader, Class<?>... primarySources) {
    this.sources = new LinkedHashSet();
    this.bannerMode = Mode.CONSOLE;
    this.logStartupInfo = true;
    this.addCommandLineProperties = true;
    this.addConversionService = true;
    this.headless = true;
    this.registerShutdownHook = true;
    this.additionalProfiles = new HashSet();
    this.isCustomEnvironment = false;
    this.lazyInitialization = false;
    this.resourceLoader = resourceLoader;
    Assert.notNull(primarySources, "PrimarySources must not be null");
    this.primarySources = new LinkedHashSet(Arrays.asList(primarySources));
    // primarySources 为 run 方法传入的引导类
    this.webApplicationType = WebApplicationType.deduceFromClasspath();
    // 推断web应用类
  this.setInitializers(this.getSpringFactoriesInstances(ApplicationContextInitializer.class));// 初始化 initializers 属性
    this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));
    //初始化监听器
    this.mainApplicationClass = this.deduceMainApplicationClass();
    //推断应用引导类
}
```



![image-20200324150140357](F:\Typora\images\image-20200324150140357.png)



# 三、日志

## 1、日志框架

小张：开发一个大型系统

		1、System.out,println("")；将关键数据打印在控制台，去掉？写在一个文件
	
		2、框架来记录一些运行时的信息：日志框架
	
		3、高大上的几个功能？异步模式？自动归档？xxxx？
	
		4、将以前框架卸下来，换上新的框架，重新修改之前的API，
	
		5、JDBC——数据库驱动：
	
				写了一个统一的接口层：日志门面（日志的一个抽象层）
	
				给项目中导入具体的日志实现就行了，我们之前的日志框架爱就是实现的抽象层



**市面上的日志框架**

JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j......

| 日志门面（日志的抽象层）                                     | 日志实现                                      |
| ------------------------------------------------------------ | --------------------------------------------- |
| ~~JCL(Jakarta Commons Logging)~~    SLF4j(Simple Logging Facade for Java)     **~~jboss-logging~~** | Log4j JUL(java.util.logging)   Log4j2 Logback |

左边选一个门面（抽象层），右边来选一个实现。

日志门面：SLF4j

日志实现：logback



Spring Boot：底层是Spring框架，Spring框架默认是用 JCL；

		**Spring Boot选用 SLF4j 和 logback**



## 2、SLF4j使用

### 1、如何在系统中使用SLF4j

以后开发的时候，日志记录方法的调用，不应该直接调用日志的实现类，而是调用日志抽象层里面的方法。

给系统里面导入 SLF4j 的jar和logback的实现jar 

```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class HelloWorld {
  public static void main(String[] args) {
    Logger logger = LoggerFactory.getLogger(HelloWorld.class);
    logger.info("Hello World");
  }
}
```

 ![img](http://www.slf4j.org/images/concrete-bindings.png) 

每一个日志的实现类框架都有自己的配置文件，使用 slf4j以后，**配置文件还是做成日志实现框架自己本身的配置文件**



### 2、遗留问题

a (slf4j + logback)：Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx

同一日志记录，即是别的框架和我一起同一使用slf4j 进行输出

 ![click to enlarge](http://www.slf4j.org/images/legacy.png) 

==**如何让系统中所有的日志都同一到 slf4j ：**==

1. 将系统中其他日志框架先排除出去
1. 用中间包来替换原有的日志框架
1. 我们导入 slf4j 其他的实现





## 3、Spring Boot日志关系

```xml
<dependency>
	<groupId>org.springframework-boot</groupId>
    <artifactId>spring-boot-starter</artifactId>
</dependency>
```

Spring Boot使用它来做日志功能：

```xml
<dependency>
	<groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-logging</artifactId>
</dependency>
```

底层依赖关系：

![image-20200105082516930](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20200105082516930.png)

总结：

1. Spring Boot底层也是使用 slf4j + logback 的方式进行日志记录

1. Spring Boot也把其他的日志都替换成立 slf4j 

1. 中间替换包

1. 如果我们要引入其他框架，一定要把这个框架的默认日志依赖移除掉

   Spring框架用的是 commons-logging

   Spring Boot能自藕丁适配所有的日志，而且底层使用 slf4j + logback 的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉。



## 4、日志使用

### 1、默认配置

Spring Boot默认帮我们配置好了日志

```java
//记录器
    Logger logger = LoggerFactory.getLogger(getClass());

    @Test
    void contextLoads() {

        //日志的级别
        //由低到高    trace<debug<info<warn<error
        //可以调整输出的日志级别，日志就只会在这个级别以后的高级别生效
        logger.trace("这是trace日志...");
        logger.debug("这是debug日志...");
        //Spring Boot默认给我们使用的是info级别的，没有指定级别的就用Spring Boot默认规定的级别
        logger.info("这是info日志");
        logger.warn("这是warn日志");
        logger.error("这是error日志");

    }
```



```
	日志输出格式：
		%d表示日期时间，
		%thread表示线程名，
		%-5level：级别从左显示5环绕字符宽度
		%logger{50}：表示logger名字最长50个字符，否则按照句点分割
		%msg：日志信息，
		%n是换行符
	%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n
```

Spring Boot修改日志的默认配置

```properties
logging.level.com.atguigu=trace

#指定日志路径
#logging.file.path  指定日志文件所在位置
#logging.file.path=H:/springboot         
#logging.file.name指定日志名字，也可以是确切位置
logging.file.name=H://springboot//a.log  

# 在控制台输出的日志的格式
logging.pattern.console=%d{yyyy-MM-dd} [%thread] %-5level %logger{50} - %msg%n
# 指定文件中日志输出的格式
logging.pattern.file=%d{yyyy-MM-dd} === [%thread] === %-5level === %logger{50} === %msg%n
```



## 2、指定配置

给类路径下放上每个日志框架自己的配置文件即可，Spring Boot就不使用其他默认配置了

| Logging System          | Customization                                                |
| ----------------------- | ------------------------------------------------------------ |
| Logback                 | `logback-spring.xml`, `logback-spring.groovy`, `logback.xml` or `logback.groovy` |
| Log4j2                  | `log4j2-spring.xml` or `log4j2.xml`                          |
| JDK (Java Util Logging) | `logging.properties`                                         |

logback.xml：直接就被日志框架识别了

logback-spring.xml：日志框架就不直接加载日志的配置类，由Spring Boot解析日志配置，可以使用Spring Boot的高级Profile功能。

```xml
<springProfile name="staging">
    <!-- configuration to be enabled when the "staging" profile is active -->
    可以指定某段配置只在某个环境下生效
</springProfile>
```

```xml
<appender name="stdout" class="ch.qos.logback.core.ConsoleAppender">
    <!--
    日志输出格式：
        %d表示日期时间，
        %thread表示线程名，
        %-5level：级别从左显示5个字符宽度
        %logger{50} 表示logger名字最长50个字符，否则按照句点分割。 
        %msg：日志消息，
        %n是换行符
    -->
    <layout class="ch.qos.logback.classic.PatternLayout">
        <springProfile name="dev">
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS}  ---> [%thread] %-5level %logger{50} - %msg%n</pattern>
        </springProfile>
        <springProfile name="!dev">
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS}  ===> [%thread] %-5level %logger{50} - %msg%n</pattern>
        </springProfile>
    </layout>
</appender>
```





## 5、切换日志框架

可以按照 slf4j 的日志适配图，进行相关的切换

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
    <exclusions>
        <exclusion>
            <artifactId>logback-classic</artifactId>
            <groupId>ch.qos.logback</groupId>
        </exclusion>
        <exclusion>
            <artifactId>log4j-over-slf4j</artifactId>
            <groupId>org.slf4j</groupId>
        </exclusion>
    </exclusions>
</dependency>

<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-log4j12</artifactId>
</dependency>
```



切换为log4j2

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
    <exclusions>
        <exclusion>
            <artifactId>spring-boot-starter-logging</artifactId>
            <groupId>org.springframework.boot</groupId>
        </exclusion>
    </exclusions>
</dependency>

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-log4j2</artifactId>
</dependency>
```





# 四、Web开发

## 1、使用Spring Boot

1. 创建Spring Boot应用，选中我们需要的模块
1. Spring Boot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来
1. 自己编写业务代码



**自动配置原理？**

这个场景Spring Boot帮我们配置了什么？能不能修改？能修改哪些配置？能不能扩展？

```
xxxxAutoConfiguration：帮我们给容器中自动配置组件
xxxxProperties：配置类来封装配置文件的内容
```



## 2、Spring Boot对静态资源的映射规则

```java
@ConfigurationProperties(
    prefix = "spring.resources",
    ignoreUnknownFields = false
)
public class ResourceProperties {
//可以设置和静态资源有关的参数、缓存时间等
```



`WebMvcAutoConfiguration` 类中

```java
public void addResourceHandlers(ResourceHandlerRegistry registry) {
    
    //如果静态资源已经被自定义了，直接在配置文件中指定的：spring.mvc.static-path-pattern=
    //可以自定义静态资源的路径，不推荐使用
    if (!this.resourceProperties.isAddMappings()) {
        logger.debug("Default resource handling disabled");
        return;
    }
    
    Duration cachePeriod = this.resourceProperties.getCache().getPeriod();
    CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();
    //通过webjars存放的位置查找
    if (!registry.hasMappingForPattern("/webjars/**")) {
        customizeResourceHandlerRegistration(registry.addResourceHandler("/webjars/**")
                .addResourceLocations("classpath:/META-INF/resources/webjars/")
                .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));
    }
    String staticPathPattern = this.mvcProperties.getStaticPathPattern();
    
    //默认指定的静态资源位置
    if (!registry.hasMappingForPattern(staticPathPattern)) {
        customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern)
                .addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations()))
                .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));
    }
}
```



```java
//配置欢迎页映射
@Bean
public WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext, FormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider) {
    WelcomePageHandlerMapping welcomePageHandlerMapping = new WelcomePageHandlerMapping(new TemplateAvailabilityProviders(applicationContext), applicationContext, this.getWelcomePage(), this.mvcProperties.getStaticPathPattern());
    welcomePageHandlerMapping.setInterceptors(this.getInterceptors(mvcConversionService, mvcResourceUrlProvider));
    return welcomePageHandlerMapping;
}
```

1. 直接在配置文件中配置静态资源位置<font color='red'>（不推荐）</font>

   ```properties
spring.mvc.static-path-pattern=
   ```

2. webjars

   ```java
   if (!registry.hasMappingForPattern("/webjars/**")) {				customizeResourceHandlerRegistration(registry.addResourceHandler("/webjars/**")
   		.addResourceLocations("classpath:/META-INF/resources/webjars/")
   .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));
   }
   ```

   

   所有/webjars/**,都去classpath:/META-INF/resources/webjars/里面找资源

   web.jars：以jar包的方式引入静态资源：

   [webjar官网](https://www.webjars.org/)

   ```xml
   <!-- 引入jquery-webjar，在访问的时候只需要引入webjars下面资源的名称即可 -->
   <dependency>
       <groupId>org.webjars</groupId>
       <artifactId>jquery</artifactId>
       <version>3.4.1</version>
   </dependency>
   ```

   **目录结构：**

   ![image-20200325104543878](F:\Typora\images\image-20200325104543878.png)

   

    【测试访问】： http://localhost:8080/webjars/jquery/3.4.1/jquery.js 

   

3. ==“/**”访问当前项目的任何资源,（静态资源的文件夹）==

   ```java
   if (!registry.hasMappingForPattern(staticPathPattern)) {
   customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern)
   .addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations()))
   .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));
   }
   ```

   对应的 `ResourceProperties`

   ```java
   @ConfigurationProperties(prefix = "spring.resources", ignoreUnknownFields = false)
   public class ResourceProperties {
   
   	private static final String[] CLASSPATH_RESOURCE_LOCATIONS = { "classpath:/META-INF/resources/",
   			"classpath:/resources/", "classpath:/static/", "classpath:/public/" };
   ```

   - classpath:/META-INT/resources
   - classpath:/resources
   - classpath:/static/
   - classpath:/public/

   localhost:8080/abc		--> 		去静态资源文件夹里面找abc

   

   **目录中含有相同名称的文件时**

   **优先级：  resource > static > public** 

   

4. ==欢迎页：静态文件夹下的所有index.html页面，被"/**"映射==

   	localhost:8080/	找index页面

   **源码：**

   `WebMvcAutoConfiguration`

   ```java
   @Bean
   public WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext,
           FormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider) {
       WelcomePageHandlerMapping welcomePageHandlerMapping = new WelcomePageHandlerMapping(
               new TemplateAvailabilityProviders(applicationContext), applicationContext, getWelcomePage(),
               this.mvcProperties.getStaticPathPattern());
       welcomePageHandlerMapping.setInterceptors(getInterceptors(mvcConversionService, mvcResourceUrlProvider));
       return welcomePageHandlerMapping;
   }
   
   private Optional<Resource> getWelcomePage() {
       String[] locations = getResourceLocations(this.resourceProperties.getStaticLocations());
       return Arrays.stream(locations).map(this::getIndexHtml).filter(this::isReadable).findFirst();
   }
   
   private Resource getIndexHtml(String location) {
       return this.resourceLoader.getResource(location + "index.html");
   }
   ```

   

5. ==所有的 **/favicon.ico 都是在静态资源文件下找==

   可以在资源文件夹中配置 favicon.icon 图标<font color='red'>【新版去掉了这个功能】</font>

   ```properties
   # 关闭默认图标
   spring.mvc.favicon.enabled=false
   ```





## 3、模板引擎

JSP、Velocity、Freemarker、Thymeleaf

![image-20200106114056775](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20200106114056775.png)

Spring Boot推荐的 Thymeleaf，语法更简单，功能更强大

### 	1、引入Thymeleaf

[Thymeleaf官方文档](https://www.thymeleaf.org/documentation.html)

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-thymeleaf</artifactId>
</dependency>

<!--导入上面的依赖会默认帮我们导入了这两个依赖-->
<dependency>
    <groupId>org.thymeleaf</groupId>
    <artifactId>thymeleaf-spring5</artifactId>
</dependency>
<dependency>
    <groupId>org.thymeleaf.extras</groupId>
    <artifactId>thymeleaf-extras-java8time</artifactId>
</dependency>
```

### 2、Thymelea使用&语法

[Thymeleaf在线使用文档](https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html)

```java
@ConfigurationProperties(
    prefix = "spring.thymeleaf"
)
public class ThymeleafProperties {
    private static final Charset DEFAULT_ENCODING;
    public static final String DEFAULT_PREFIX = "classpath:/templates/";
    public static final String DEFAULT_SUFFIX = ".html";
```

只要我们把html页面放在 `classpath:/templates/` 就能自动渲染，但 `templates` 文件夹下面的页面不能直接访问到，需要跳转。

使用：

1. 导入 thymeleaf 

   ```java
   <html xmlns:th="http://www.thymeleaf.org">
   ```

1. 编写 `controller` 类

   ```java
   @Controller
   @RequestMapping("/cyy")
   public class MyController {
   
       @RequestMapping("test")
       public String test(Model model){
           model.addAttribute("msg","<h1>Hello World</h1>");
           model.addAttribute("users", Arrays.asList("张三","李四"));
           return "test";
       }
   }
   ```
   
1. 使用 `thymeleaf` 语法：

   ```html
   <!DOCTYPE html>
   <html lang="en" xmlns:th="http://www.thymeleaf.org">
   <head>
       <meta charset="UTF-8">
       <title>Title</title>
   </head>
   <body>
   
       <!--所有的html元素都可以被 thymeleaf 替换接管：	th:元素名-->
       <div th:text="${msg}">Test</div>
       <div th:utext="${msg}">Test</div>   <!--转义-->
   
       <hr>
   
       <h6>第一种写法</h6>
       <p th:each="user:${users}" th:text="${user}"></p>       <br>
   
       <h6>第二种写法</h6>
       <p th:each="user:${users}">[[${user}]]</p>
   
   </body>
   </html>
   ```

【效果】：

![image-20200325144306228](F:\Typora\images\image-20200325144306228.png)

### 3、语法规则

1. th:text：改变当前元素

   th：任意html属性，来替换原生属性的值

   ![image-20200106181418867](F:\Typora\images\image-20200106181418867.png)

1. 表达式？

   ```properties
   Simple expressions:（表达式语法）
       Variable Expressions: ${...}：获取变量值；OGNL；
       		1）、获取对象的属性、调用方法
       		2）、使用内置的基本对象：
       			#ctx : the context object.
       			#vars: the context variables.
                   #locale : the context locale.
                   #request : (only in Web Contexts) the HttpServletRequest object.
                   #response : (only in Web Contexts) the HttpServletResponse object.
                   #session : (only in Web Contexts) the HttpSession object.
                   #servletContext : (only in Web Contexts) the ServletContext object.
                   
                   ${session.foo}
               3）、内置的一些工具对象：
   #execInfo : information about the template being processed.
   #messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #{…} syntax.
   #uris : methods for escaping parts of URLs/URIs
   #conversions : methods for executing the configured conversion service (if any).
   #dates : methods for java.util.Date objects: formatting, component extraction, etc.
   #calendars : analogous to #dates , but for java.util.Calendar objects.
   #numbers : methods for formatting numeric objects.
   #strings : methods for String objects: contains, startsWith, prepending/appending, etc.
   #objects : methods for objects in general.
   #bools : methods for boolean evaluation.
   #arrays : methods for arrays.
   #lists : methods for lists.
   #sets : methods for sets.
   #maps : methods for maps.
   #aggregates : methods for creating aggregates on arrays or collections.
   #ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration).
   
       Selection Variable Expressions: *{...}：选择表达式：和${}在功能上是一样；
       	补充：配合 th:object="${session.user}：
      <div th:object="${session.user}">
       <p>Name: <span th:text="*{firstName}">Sebastian</span>.</p>
       <p>Surname: <span th:text="*{lastName}">Pepper</span>.</p>
       <p>Nationality: <span th:text="*{nationality}">Saturn</span>.</p>
       </div>
       
       Message Expressions: #{...}：获取国际化内容
       Link URL Expressions: @{...}：定义URL；
       		@{/order/process(execId=${execId},execType='FAST')}
       Fragment Expressions: ~{...}：片段引用表达式
       		<div th:insert="~{commons :: main}">...</div>
       		
   Literals（字面量）
         Text literals: 'one text' , 'Another one!' ,…
         Number literals: 0 , 34 , 3.0 , 12.3 ,…
         Boolean literals: true , false
         Null literal: null
         Literal tokens: one , sometext , main ,…
   Text operations:（文本操作）
       String concatenation: +
       Literal substitutions: |The name is ${name}|
   Arithmetic operations:（数学运算）
       Binary operators: + , - , * , / , %
       Minus sign (unary operator): -
   Boolean operations:（布尔运算）
       Binary operators: and , or
       Boolean negation (unary operator): ! , not
   Comparisons and equality:（比较运算）
       Comparators: > , < , >= , <= ( gt , lt , ge , le )
       Equality operators: == , != ( eq , ne )
   Conditional operators:条件运算（三元运算符）
       If-then: (if) ? (then)
       If-then-else: (if) ? (then) : (else)
       Default: (value) ?: (defaultvalue)
   Special tokens:
       No-Operation: _ 
   ```

   

## 4、SpringMVC自动配置

[1.5.1版本](https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications)

[2.2.6版本：7.11](https://docs.spring.io/spring-boot/docs/2.2.6.RELEASE/reference/html/spring-boot-features.html#boot-features)

###  1、Spring MVC auto-configuration

Spring Boot自动配置好了SpringMVC

以下是SpringBoot对SpringMVC的默认：

- Inclusion of `ContentNegotiatingViewResolver` and `BeanNameViewResolver` beans.
  - 自动配置类ViewResolver（视图解析器：根据方法的返回值得到视图解析器(View)，视图对象决定如何渲染(转发？重定向？)）
  - ContentNegotiatingViewResolver :组合所有的视图解析器
  - ==如何订制：我们可以自己给容器中添加一个视图解析器，自动的将其组合起来==
  
- Support for serving static resources, including support for WebJars (see below)：静态资源文件夹路径.webjars

- Automatic registration of `Converter`, `GenericConverter`, `Formatter` beans.自动注册

  - Converter：转换器：punliv String hello(User user)：类型转换使用Converter
  - Formatter：格式化器：2017/12/17 === Date

  ```java
  public void addFormatters(FormatterRegistry registry) {
      ApplicationConversionService.addBeans(registry, this.beanFactory);
  }
  ```

  - ==自己添加的格式化器转换器，我们只需要放在容器中即可==

- Support for `HttpMessageConverters` (see below).

  - HttpMessageConverters：SpringMVC用来转换Http请求和相应的：User--json

  - HttpMessageConverters：是从容器中确定，获取所有的HttpMessageConverter:

    ==自己给容器中添加HttpMessageConverters，只需要将自己的组件注册容器中(@Bean,@Component)==

- Automatic registration of `MessageCodesResolver` (see below)：定义错误代码生成规则

- Static `index.html` support.：静态首页访问

- Custom `Favicon` support (see below).

- Automatic use of a `ConfigurableWebBindingInitializer` bean (see below).

  - 我们可以配置一个ConfigurableWebBindingInitializer来替换默认的（添加到容器）

    ```
    初始化WebDataBinder
    请求数据 ---- javaBean
    ```

**org.springframework.boot.autoconfigure.web：web的所有自动场景** 

If you want to keep Spring Boot MVC features, and you just want to add additional [MVC configuration](https://docs.spring.io/spring/docs/4.3.14.RELEASE/spring-framework-reference/htmlsingle#mvc) (interceptors, formatters, view controllers etc.) you can add your own `@Configuration` class of type `WebMvcConfigurerAdapter`, but **without** `@EnableWebMvc`. If you wish to provide custom instances of `RequestMappingHandlerMapping`, `RequestMappingHandlerAdapter` or`ExceptionHandlerExceptionResolver` you can declare a `WebMvcRegistrationsAdapter` instance providing such components.

If you want to take complete control of Spring MVC, you can add your own `@Configuration` annotated with `@EnableWebMvc`.



### 2、自定义视图解析器

If you want to keep those Spring Boot MVC customizations and make more MVC customizations(interceptors, formatters, view controllers, and other features), you can add your own `@Configuration` class of type `WebMvcConfigurer`but **without** `@EnableWebMvc`.

```java
//如果你想diy一些定制化的功能，只要写这个组件，然后将它交给SpringBoot，SpringBoot就会帮我妈自动装配
//全面接管SpringMVC
@Configuration
public class MyMvcConfig implements WebMvcConfigurer {

    //ViewResolver 实现了视图解析器接口的类，我们就可以把它看做视图解析器
    @Bean
    public ViewResolver myViewResovler(){
        return new MyViewResolver();
    }

    public static class MyViewResolver implements ViewResolver{

        @Override
        public View resolveViewName(String s, Locale locale) throws Exception {
            return null;
        }
    }
}
```

【测试】所有的视图解析器都会经过 `DispatcherServlet` 的 `doDispatch` 方法，我们在此处打个断点，然后进行调试

![image-20200327110150620](F:\Typora\images\image-20200327110150620.png)



SpringBoot 在自动配置很多组件的时候，先看容器中有没有用户自己配置的（如果用户自己配置@Bean），如果有就用用户配置的，如果没有就用自动配置的；有些组件可以存在多个，比如我们的视图解析器，就将用户配置和自己默认的组合起来。



### 3、扩展SpringMVC

```xml
<mvc:interceptors>
    <mvc:interceptor>
        <mvc:mapping path="/hello"/>
        <bean></bean>
    </mvc:interceptor>
</mvc:interceptors>
```

==编写一个配置类(@Configuration)，是 WebMvcConfigurerAdapter 类型，不能标注 @EnableWebMvc==

既保留了所有的自动配置，也能用我们扩展的配置

```java
//扩展SpringMVC的功能
@Configuration
public class MyMvcConfig implements WebMvcConfigurer {
//public class MyMvcConfig extends WebMvcConfigurerAdapter //此继承已经过时

    @Override
    public void addViewControllers(ViewControllerRegistry registry) {
        //浏览器发送 /atguigu 请求来到 success
        registry.addViewController("/atguigu").setViewName("success");
    }
}
```

原理：

1. WebMvcAutoConfiguration 是 SpringMVC的自动配置类
1. 在做其他自动配置时会导入：@Import(EnableWebMvcConfiguration.class)

```java
@Configuration
public static class EnableWebMvcConfiguration extends DelegatiingWebMvcConfiguration{
    private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite();
    
    //从容器中获取所有的WebMvcConfigurer
    @Autowired(required = false)
    public void setConfigurers(List<WebMvcConfigurer> configurers){
        if(!CollectionUtils.isEmpty(configurers)){
            this.configurers.addWebMvcConfigurers(configurers);
            //一个参考实现，将所有的 WebMvcConfigurer 相关配置都来一起调用
            /*
            @Override
            public void addViewControllers(ViewControllerReglistry registry){
                for (WebMvcConfigurer delegate : this,delefates){
                    delegate.addViewControllers(registry);
                }
            }
            */
        }
    }
}
```

3. 容器中所有的 WebMvcConfigurer 都会一起起作用

3. 我们的配置也会被调用

   效果：SpringMVC的自动配置和我们的扩展配置都会起作用



### 4、全面接管SpringMVC

Spring Boot对SpringMVC的自动配置不需要了，所有都是我们自己配：所有的SpringMVC的自动配置都失效

我们需要在配置类中添加 @EnableWebMvc 即可

```java
//扩展SpringMVC的功能
@EnableWebMvc
@Configuration
public class MyMvcConfig implements WebMvcConfigurer {
//public class MyMvcConfig extends WebMvcConfigurerAdapter {

    @Override
    public void addViewControllers(ViewControllerRegistry registry) {
        //浏览器发送 /atguigu 请求来到 success
        registry.addViewController("/atguigu").setViewName("success");
    }
}
```

原理：

	为什么 @EnableWebMvc 自动配置就失效了

1. @ EnableWebMvc 的核心

   ```java
   @Retention(RetentionPolicy.RUNTIME)
   @Target({ElementType.TYPE})
   @Documented
   @Import({DelegatingWebMvcConfiguration.class})//DelegatingWebMvcConfiguration类
   public @interface EnableWebMvc {
   }
   ```

1.  

   ```java
   @Configuration(
       proxyBeanMethods = false
   )
   public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport {
   ```

1.  

   ```java
   @Configuration(
       proxyBeanMethods = false
   )
   @ConditionalOnWebApplication(
       type = Type.SERVLET
   )
   @ConditionalOnClass({Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class})
   @ConditionalOnMissingBean({WebMvcConfigurationSupport.class})
   //容器中没有这个组件的时候，这个自动配置类才生效
   @AutoConfigureOrder(-2147483638)
   @AutoConfigureAfter({DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class, ValidationAutoConfiguration.class})
   public class WebMvcAutoConfiguration {
   ```

1. @EnableWebMvc 将 WebMvcConfigurationSupport组件导入进来

1. 导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能



## 5、如何修改Spring Boot的默认配置

模式：

1. Spring Boot在自动配置很多组件的时候，先看容器中有没有字节配置的（@Bean、@Component），如果有，就用用户配置的，如果没有才自动配置；如果有些组件可以有多个（ViewResolver）将用户配置的和自己默认的组合起来
1. 在Spring Boot中会有非常多的 xxxConfigurer 帮助我们进行扩展配置
1. 在SpringBoot中有会有很多的 xxxCustomizer 帮助我们进行定制配置



## 6、RestfulCRUD

### 1、默认访问首页

```java
@RequestMapping({"/",".html"})
public String index(){
    return "index";
}
```

注：WebMvcConfigurerAdapter 类已过时（不推荐使用）

```java
@Bean//将组件注册在容器中
public WebMvcConfigurer webMvcConfigurer(){
    WebMvcConfigurer configurer = new WebMvcConfigurerAdapter() {
        @Override
        public void addViewControllers(ViewControllerRegistry registry) {
            registry.addViewController("/").setViewName("login");
            registry.addViewController("/login.html").setViewName("login");
        }
    };
    return configurer;
}
```

### 2、国际化

1. 编写国际化配置文件

1. 使用 ResourceBundleMessageSource 管理国际化资源文件

1. 在页面使用 fmt:message 取出国际化内容

    

步骤：

1. 编写国际化配置文件，抽取页面需要显示的国际化消息

   ![image-20200107111646913](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20200107111646913.png)

1. Spring Boot自动配置好了管理国际化资源文件的组件

   ```java
   @Conditional({MessageSourceAutoConfiguration.ResourceBundleCondition.class})
   @EnableConfigurationProperties
   public class MessageSourceAutoConfiguration {
   ```

   配置文件中编写配置

   ```properties
   # 我们的配置文件的真实位置
   spring.messages.basename=i18n.login
   ```

1. 去页面获取国际化的值

```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">
    <title>Signin Template for Bootstrap</title>
    <!-- Bootstrap core CSS -->
    <link th:href="@{/css/bootstrap.min.css}" href="../static/css/bootstrap.min.css" rel="stylesheet">
    <!-- Custom styles for this template -->
    <link th:href="@{/css/signin.css}" href="../static/css/signin.css" rel="stylesheet">
</head>

<body class="text-center">
<form class="form-signin" action="dashboard.html">
    <img class="mb-4" th:src="@{img/bootstrap-solid.svg}" alt="" width="72" height="72">
    <h1 class="h3 mb-3 font-weight-normal" th:text="#{login.tip}">Please sign in</h1>
    <input type="text" class="form-control" th:placeholder="#{login.username}" required="" autofocus="">
    <input type="password" class="form-control" th:placeholder="#{login.password}" required="">
    <div class="checkbox mb-3">
        <label>
            <input type="checkbox" value="remember-me"> [[#{login.remember}]]
        </label>
    </div>
    <button class="btn btn-lg btn-primary btn-block" type="submit">[[#{login.btn}]]</button>
    <p class="mt-5 mb-3 text-muted">© 2017-2018</p>
    <a class="btn btn-sm" th:href="@{/index.html(language='zn_CN')}">中文</a>
    <a class="btn btn-sm" th:href="@{/index.html(language='en_US')}">English</a>
</form>

</body>

</html>
```



原理：

		国际化 Locate（区域信息对象）：LocaleResolver（获取区域信息对象）

```java
@Bean
@ConditionalOnMissingBean
@ConditionalOnProperty(
    prefix = "spring.mvc",
    name = {"locale"}
)
public LocaleResolver localeResolver() {
    if (this.mvcProperties.getLocaleResolver() == org.springframework.boot.autoconfigure.web.servlet.WebMvcProperties.LocaleResolver.FIXED) {
        return new FixedLocaleResolver(this.mvcProperties.getLocale());
    } else {
        AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver();
        localeResolver.setDefaultLocale(this.mvcProperties.getLocale());
        return localeResolver;
    }
}

//默认的就是根据请求头带来的区域信息获取Locale进行国际化
```

4. 点击链接切换国际化

```java
@Configuration
public class CyyLocaleResolver implements LocaleResolver {
    @Override
    public Locale resolveLocale(HttpServletRequest request) {
        //获取请求中的语言参数
        String language = request.getParameter("language");
        //如果没有就是用默认的
        Locale locale = Locale.getDefault();
        //如果请求的链接携带了国际化的参数
        if (!StringUtils.isEmpty(language)) {
            //zh_CN
            String[] s = language.split("_");
            locale = new Locale(s[0], s[1]);
        }
        return locale;
    }

    @Override
    public void setLocale(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Locale locale) {

    }
}
```

5. 在配置类中将其加入组件中

```java
@Bean
public LocaleResolver localeResolver(){
    return new CyyLocaleResolver();
}
```



### 3、登录

模板引擎修改以后，要实时生效：

1. 禁用模板引擎的缓存

   ```properties
   # 禁用缓存
   spring.thymeleaf.cache=false
   ```

1. 页面修改完成以后 Ctrl+F9 ，重新编译

   登录错误消息的提示

```html
<p style="color: red;" th:text="${msg}" th:if="${not #strings.isEmpty(msg)}"></p>
```

```java
@Controller
public class LoginController {

    @RequestMapping("/user/login")
    public String login(@RequestParam("username") String username,
                        @RequestParam("password") String password,
                        Model model, HttpSession session) {

        //具体的业务
        if (username.equals("root") && password.equals("123456")) {
            session.setAttribute("loginUser",username);
            return "redirect:/main.html";
        } else {
            model.addAttribute("msg", "用户名或密码错误");
            return "index";
        }
    }
}
```



### 4、拦截器进行登录检查

```java
/**
 * 登录检查
 */
public class LoginHandlerInterceptor implements HandlerInterceptor {

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {

        //登录成功之后，应该有用户的session
        Object loginUser = request.getSession().getAttribute("loginUser");

        if (loginUser == null) {
            request.setAttribute("msg", "没有权限，请登录");
            request.getRequestDispatcher("/index.html").forward(request, response);
            return false;
        }

        return true;
    }
}
```

把拦截器加入到我们的容器中

```java
@Override
public void addInterceptors(InterceptorRegistry registry) {
    registry.addInterceptor(new LoginHandlerInterceptor())
            .addPathPatterns("/**")
            .excludePathPatterns("/index.html","/","/user/login","/css/**","/img/**","/js/**");
}
```



### 5、CRUD-员工列表

实验要求：

1. RestfulCRUD：CRUD满足Rest风格

   URI：/资源名称/资源标识		HTTP请求方式区分对资源CRUD操作

   |      | 普通CRUD(uri来区分操作) | RestfulCRUD       |
   | ---- | ----------------------- | ----------------- |
   | 查询 | getEmp                  | emp---GET         |
   | 添加 | addEmp?xxx              | emp---POST        |
   | 修改 | updateEmp?id=xxx&xxx=xx | emp/{id}---PUT    |
   | 删除 | deleteEmp?id=1          | emp/{id}---DELETE |

1. 实验的请求架构

   | 实验功能                             | 请求URI  | 请求方式 |
   | ------------------------------------ | -------- | -------- |
   | 查询所有员工                         | emps     | GET      |
   | 查询某个员工（来到修改页面）         | emp/{id} | GET      |
   | 来到添加页面                         | emp      | GET      |
   | 添加员工                             | emp      | POST     |
   | 来到修改页面（查出员工进行信息回显） | emp/{id} | GET      |
   | 修改员工                             | emp      | PUT      |
   | 删除员工                             | emp/{id} | DELETE   |

   

1. 员工列表

   **thymeleaf公共页面元素抽取**

   ```html
   1、抽取公共片段
   <div th:fragment="copy">
       &copy;2011 The Good Thynes Virtual Grocery
   </div>
   
   2、引入公共片段
   <div th:insert="~{footer :: copy}"></div>
   ~{templatename::sekector}：模板名::选择器
   ~{templatename::fragmentname}：模板名::片段名
   
   3、默认效果
   insert的功能片段在div标签中
   如果使用th:insert等属性进行引入，可以不用写~{}
   行内写法可以加上：[[~{}]],[(~{})]
   ```

    

   三种引入功能片段 th 属性

   - **th:insert**：将公共片段整个插入到声明引入的元素中
   - **th:replace**：将声明引入的元素替换为公共片段
   - **th:include**：将被引入包含进这个标签中

   ```html
   <footer th:fragment="copy">
   	&copy;2011 The Good Thymes Virtual Grocery
   </footer>
   
   引入方式
   <div th:insert="footer :: copy"></div>
   <div th:replace="footer :: copy"></div>
   <div th:include="footer :: copy"></div>
   
   效果
   <div>
       <footer>
       	&copy;2011 The Good Thymes Virtual Grocery
       </footer>
   </div>
   
   <footer>
   	&copy;2011 The Good Thymes Virtual Grocery
   </footer>
   
   <div>
       &copy;2011 The Good Thymes Virtual Grocery
   </div>
   ```

    

   引入片段的时候传入参数

```html

<nav class="col-md-2 d-none d-md-block bg-light sidebar" id="sidebar">
    <div class="sidebar-sticky">
        <ul class="nav flex-column">
            <li class="nav-item">
                <a class="nav-link active"
                   th:class="${activeUri=='main.html'?'nav-link active':'nav-link'}"
                   href="#" th:href="@{/main.html}">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-home">
                        <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
                        <polyline points="9 22 9 12 15 12 15 22"></polyline>
                    </svg>
                    Dashboard <span class="sr-only">(current)</span>
                </a>
            </li>

<!--引入侧边栏;传入参数-->
<div th:replace="commons/bar::#sidebar(activeUri='emps')"></div>
```

### 6、CRUD-员工添加

添加页面

```html
<form>
    <div class="form-group">
        <label>LastName</label>
        <input type="text" class="form-control" placeholder="zhangsan">
    </div>
    <div class="form-group">
        <label>Email</label>
        <input type="email" class="form-control" placeholder="zhangsan@atguigu.com">
    </div>
    <div class="form-group">
        <label>Gender</label><br/>
        <div class="form-check form-check-inline">
            <input class="form-check-input" type="radio" name="gender"  value="1">
            <label class="form-check-label">男</label>
        </div>
        <div class="form-check form-check-inline">
            <input class="form-check-input" type="radio" name="gender"  value="0">
            <label class="form-check-label">女</label>
        </div>
    </div>
    <div class="form-group">
        <label>department</label>
        <select class="form-control">
            <option>1</option>
            <option>2</option>
            <option>3</option>
            <option>4</option>
            <option>5</option>
        </select>
    </div>
    <div class="form-group">
        <label>Birth</label>
        <input type="text" class="form-control" placeholder="zhangsan">
    </div>
    <button type="submit" class="btn btn-primary">添加</button>
</form>
```

提交的数据格式不对：生日：日期；

2017-12-12；2017/12/12；2017.12.12；

日期的格式化；SpringMVC将页面提交的值需要转换为指定的类型;

2017-12-12---Date； 类型转换，格式化;

默认日期是按照/的方式；



### 7、CRUD-员工修改

```html
<!--需要区分是员工修改还是添加；-->
<form th:action="@{/emp}" method="post">
    <!--发送put请求修改员工数据-->
    <!--
1、SpringMVC中配置HiddenHttpMethodFilter;（SpringBoot自动配置好的）
2、页面创建一个post表单
3、创建一个input项，name="_method";值就是我们指定的请求方式
-->
    <input type="hidden" name="_method" value="put" th:if="${emp!=null}"/>
    <input type="hidden" name="id" th:if="${emp!=null}" th:value="${emp.id}">
    <div class="form-group">
        <label>LastName</label>
        <input name="lastName" type="text" class="form-control" placeholder="zhangsan" th:value="${emp!=null}?${emp.lastName}">
    </div>
    <div class="form-group">
        <label>Email</label>
        <input name="email" type="email" class="form-control" placeholder="zhangsan@atguigu.com" th:value="${emp!=null}?${emp.email}">
    </div>
    <div class="form-group">
        <label>Gender</label><br/>
        <div class="form-check form-check-inline">
            <input class="form-check-input" type="radio" name="gender" value="1" th:checked="${emp!=null}?${emp.gender==1}">
            <label class="form-check-label">男</label>
        </div>
        <div class="form-check form-check-inline">
            <input class="form-check-input" type="radio" name="gender" value="0" th:checked="${emp!=null}?${emp.gender==0}">
            <label class="form-check-label">女</label>
        </div>
    </div>
    <div class="form-group">
        <label>department</label>
        <!--提交的是部门的id-->
        <select class="form-control" name="department.id">
            <option th:selected="${emp!=null}?${dept.id == emp.department.id}" th:value="${dept.id}" th:each="dept:${depts}" th:text="${dept.departmentName}">1</option>
        </select>
    </div>
    <div class="form-group">
        <label>Birth</label>
        <input name="birth" type="text" class="form-control" placeholder="zhangsan" th:value="${emp!=null}?${#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')}">
    </div>
    <button type="submit" class="btn btn-primary" th:text="${emp!=null}?'修改':'添加'">添加</button>
</form>
```



### 8、CRUD-员工删除

```html
<tr th:each="emp:${emps}">
    <td th:text="${emp.id}"></td>
    <td>[[${emp.lastName}]]</td>
    <td th:text="${emp.email}"></td>
    <td th:text="${emp.gender}==0?'女':'男'"></td>
    <td th:text="${emp.department.departmentName}"></td>
    <td th:text="${#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')}"></td>
    <td>
        <a class="btn btn-sm btn-primary" th:href="@{/emp/}+${emp.id}">编辑</a>
        <button th:attr="del_uri=@{/emp/}+${emp.id}" class="btn btn-sm btn-danger deleteBtn">删除</button>
    </td>
</tr>


<script>
    $(".deleteBtn").click(function(){
        //删除当前员工的
        $("#deleteEmpForm").attr("action",$(this).attr("del_uri")).submit();
        return false;
    });
</script>
```





## 7、错误处理机制

### 1、SpringBoot默认的错误处理机制

默认效果：

1. 浏览器，返回一个默认的错误页面

![image-20200109175638561](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20200109175638561.png)

		浏览器发送请求的请求头：
	
		![image-20200109210404467](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20200109210404467.png)

2. 如果是其他客户端，默认响应一个json数据

   ![image-20200109195828456](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20200109195828456.png)

   ![image-20200109210701876](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20200109210701876.png)

原理：

		可以参照 ErrorMvcAutoConfiguration，错误处理的自动配置
	
		给容器中添加了以下组件

1. DefaultErrorAttributes

```java
//帮我们在页面共享数据
public Map<String, Object> getErrorAttributes(WebRequest webRequest, boolean includeStackTrace) {
    Map<String, Object> errorAttributes = new LinkedHashMap();
    errorAttributes.put("timestamp", new Date());
    this.addStatus(errorAttributes, webRequest);
    this.addErrorDetails(errorAttributes, webRequest, includeStackTrace);
    this.addPath(errorAttributes, webRequest);
    return errorAttributes;
}
```

2. BasicErrorController

```java
@Controller
@RequestMapping({"${server.error.path:${error.path:/error}}"})
public class BasicErrorController extends AbstractErrorController {
    
    @RequestMapping(
        produces = {"text/html"}//产生html类型的数据，浏览器发送的请求来到这个方法处理
    )
    public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) {
        HttpStatus status = this.getStatus(request);
        Map<String, Object> model = Collections.unmodifiableMap(this.getErrorAttributes(request, this.isIncludeStackTrace(request, MediaType.TEXT_HTML)));
        response.setStatus(status.value());
        
        //去哪个页面作为错误页面，包含页面地址和页面内容
        ModelAndView modelAndView = this.resolveErrorView(request, response, status, model);
        return modelAndView != null ? modelAndView : new ModelAndView("error", model);
    }

    @RequestMapping		//产生json数据，其他客户端来到这个方法处理
    public ResponseEntity<Map<String, Object>> error(HttpServletRequest request) {
        HttpStatus status = this.getStatus(request);
        if (status == HttpStatus.NO_CONTENT) {
            return new ResponseEntity(status);
        } else {
            Map<String, Object> body = this.getErrorAttributes(request, this.isIncludeStackTrace(request, MediaType.ALL));
            return new ResponseEntity(body, status);
        }
    }
    
```



3. ErrorPageCustomizer

```java
@Value("${error.path:/error}")
private String path = "/error";//系统出现错误后来到error请求进行处理,类似webxml注册的错误页面规则
```

4. DefaultErrorViewResolver

```java
public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map<String, Object> model) {
    ModelAndView modelAndView = this.resolve(String.valueOf(status.value()), model);
    if (modelAndView == null && SERIES_VIEWS.containsKey(status.series())) {
        modelAndView = this.resolve((String)SERIES_VIEWS.get(status.series()), model);
    }

    return modelAndView;
}

private ModelAndView resolve(String viewName, Map<String, Object> model) {
    //默认SpringBoot可以去找到一个页面？  error/404
    String errorViewName = "error/" + viewName;
    
    //模板引擎可以节气这个页面就用模板引擎解析
    TemplateAvailabilityProvider provider = this.templateAvailabilityProviders.getProvider(errorViewName, this.applicationContext);
    //模板引擎可用的情况下返回到errorViewName指定的视图地址
    //模板引擎不可用，就在静态资源文件夹下找errorViewName对应的页面		error/404.html
    return provider != null ? new ModelAndView(errorViewName, model) : this.resolveResource(errorViewName, model);
}
```





**步骤：**

	一旦系统出现 4xx 或者 5xx 之类的错误，ErrorPageCustomizer 就会生效（定制错误的响应规则），就会来到/error请求，又会被 **BasicErrorController** 处理

1. 响应页面,去哪个页面是由 **DefaultErrorViewResolver**

   ```java
   protected ModelAndView resolveErrorView(HttpServletRequest request, HttpServletResponse response, HttpStatus status, Map<String, Object> model) {
       Iterator var5 = this.errorViewResolvers.iterator();
   
       //所有的ErrorViewResolver得到ModelAndView
       ModelAndView modelAndView;
       do {
           if (!var5.hasNext()) {
               return null;
           }
   
           ErrorViewResolver resolver = (ErrorViewResolver)var5.next();
           modelAndView = resolver.resolveErrorView(request, status, model);
       } while(modelAndView == null);
   
       return modelAndView;
   }
   ```

   



### 2、如何订制错误相应：

#### 1、如何订制错误的页面

1. **有模板引擎的情况下：/error/状态码**   【将错误页面命名为 错误状态码.html放在模板引擎文件夹里面的error文件夹下】，发生此状态码的错误就会来到对应的页面

   - 我们可以使用 4xx 和 5xx 作为错误页面的文件名来匹配这种类型的所有错误，精确优先（优先寻找精确的状态码.html）
   - 页面能获取的信息:
     - timestamp：时间戳
     - status：状态码
     - error：错误提示
     - exception：异常对象
     - message：异常消息
     - errors：JSR303数据校验的错误就在这里

1. **没有模板引擎(模板引擎找不到这个错误页面)**，静态资源文件夹下找

1. 以上都没有错误页面，就是默认来到 SpringBoot 中的默认页面

   

#### 2、如何订制错误的json数据

1. 自定义异常处理器&返回订制json数据

```java
@ControllerAdvice
public class MyExceptionHandler {

    @ResponseBody
    @ExceptionHandler(UserNotExistException.class)
    public Map<String,Object> handleException(Exception e){

        Map<String,Object> map = new HashMap<String, Object>();
        map.put("code","user.notexit");
        map.put("message",e.getMessage());
        return map;

    }
}
//没有自适应效果……
```

2. 转发到error进行自适应相应效果处理

```java
@ExceptionHandler(UserNotExistException.class)
public String handleException(Exception e, HttpServletRequest request){

    Map<String,Object> map = new HashMap<String, Object>();
    //传入我们自己的错误状态码  4xx  5xx,否则就不会进入订制错误页面的解析流程
    //Integer statusCode = (Integer)request.getAttribute("javax.servlet.error.status_code");
    request.setAttribute("javax.servlet.error.status_code",500);
    map.put("code","user.notexit");
    map.put("message",e.getMessage());
    return "forward:/error";

}
```

3. 将我们的订制数据携带出去

出现错误以后，会来到 /error 请求，会被 BasicErrorController 处理，相应出去可以获取的数据是由 getErrorAttributes 得到的 （是 AbstractErrorController （ErrorController） 规定的方法）

		1、编写一个 ErrorController 的实现类【或者是编写AbstractErrorController的子类】，放在容器中
	
		2、页面上能用的数据，或者是json返回能用的数据都是通过 errorAttributes.getErrorAttributes 得到
	
					容器中 DefaultErrorAttributes.getErrorAttributes()；默认进行数据处理的

自定义ErrorAttributes：

```java
//给容器中加入我们自己定义的ErrorAttributes
@Component
public class MyErrorAttributes extends DefaultErrorAttributes {

    @Override
    public Map<String, Object> getErrorAttributes(WebRequest webRequest, boolean includeStackTrace) {
        Map<String, Object> map = super.getErrorAttributes(webRequest, includeStackTrace);
        map.put("company","atguigu");
        return map;
    }
}
```

最终的效果：相应是自适应的，可以通过订制 ErrorAttributes 改变需要返回的内容





## 8、配置嵌入式Servlet容器

SpringBoot默认使用Tomcat作为嵌入式的Servlet容器

![image-20200110103406521](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20200110103406521.png)

**问题：**

### 1、如何订制和修改Servlet容器的相关配置

1. 修改和server的相关配置（ServerProperties）

   ```properties
   server.port=8081
   
   server.servlet.context-path=/crud
   
   server.tomcat.uri-encoding=UTF-8
   
   //通用的Servlet容器设置
   server.xxx
   //Tomcat设置
   ```

1. 编写一个 **WebServerFactoryCustomizer**：嵌入式的Servlet容器的定制器（来修改Servlet容器的配置）

   ```java
   @Bean
   public WebServerFactoryCustomizer<ConfigurableServletWebServerFactory> webServerFactoryCustomizer(){
       return new WebServerFactoryCustomizer<ConfigurableServletWebServerFactory>() {
           @Override
           public void customize(ConfigurableServletWebServerFactory factory) {
               factory.setPort(8083);
           }
       };
   }
   ```

   



### 2、注册Servlet三大组件【Servlet、Filter、Listener】

由于SpringBoot默认是以 jar 包的方式启动嵌入式的 Servlet 容器来启动SpringBoot的web应用，没有web.xml文件

注册三大组件用以下方式：

- ServletRegistrationBean

  ```java
  //注册三大组件
  @Bean
  public ServletRegistrationBean myServlet(){
      ServletRegistrationBean registrationbean = new ServletRegistrationBean(new MyServlet(), "/myServlet");
      return registrationbean;
  }
  ```

- FilterRegistrationBean

  ```java
  @Bean
  public FilterRegistrationBean myFilter(){
      FilterRegistrationBean registrationBean = new FilterRegistrationBean();
      registrationBean.setFilter(new MyFilter());
      registrationBean.setUrlPatterns(Arrays.asList("/hello","/myServlet"));
      return registrationBean;
  }
  ```

- ServletListenerRegistrationBean

  ```java
  @Bean
  public ServletListenerRegistrationBean myListener(){
      ServletListenerRegistrationBean<MyListener> registrationBean = new ServletListenerRegistrationBean<>(new MyListener());
      return registrationBean;
  }
  ```

  SpringBoot 帮我们自动SpringMVC的时候，自动的注册SpringMVC的前端控制器：DispatcherServlet

  ```java
  @Bean(
      name = {"dispatcherServletRegistration"}
  )
  @ConditionalOnBean(
      value = {DispatcherServlet.class},
      name = {"dispatcherServlet"}
  )
  public DispatcherServletRegistrationBean dispatcherServletRegistration(DispatcherServlet dispatcherServlet, WebMvcProperties webMvcProperties, ObjectProvider<MultipartConfigElement> multipartConfig) {
      
      //默认拦截： / 所有请求，包括静态资源，但是不拦截jsp请求   /* 会拦截jsp
      //可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径
      DispatcherServletRegistrationBean registration = new DispatcherServletRegistrationBean(dispatcherServlet, webMvcProperties.getServlet().getPath());
      registration.setName("dispatcherServlet");
      registration.setLoadOnStartup(webMvcProperties.getServlet().getLoadOnStartup());
      multipartConfig.ifAvailable(registration::setMultipartConfig);
      return registration;
  }
  ```

  



### 3、替换为其他嵌入式Servlet容器

![image-20200110122620611](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20200110122620611.png)

默认支持：

- Tomcat（默认使用）

  ```xml
  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId>
      <!--引入web模块默认就是使用嵌入式的Tomcat作为servlet容器-->
  </dependency>
  ```

- Jetty

  ```xml
  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId>
      <exclusions>
          <exclusion>
              <groupId>org.springframework.boot</groupId>
              <artifactId>spring-boot-starter-tomcat</artifactId>
          </exclusion>
      </exclusions>
  </dependency>
  
  <!--引入其他的Servlet容器-->
  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-jetty</artifactId>
  </dependency>
  ```

- Undertow

  ```xml
  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId>
      <exclusions>
          <exclusion>
              <groupId>org.springframework.boot</groupId>
              <artifactId>spring-boot-starter-tomcat</artifactId>
          </exclusion>
      </exclusions>
  </dependency>
  
  <!--引入其他的Servlet容器-->
  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-undertow</artifactId>
  </dependency>
  ```

  



### 4、嵌入式Servlet容器自动配置原理

ServletWebServerFactoryAutoConfiguration ：嵌入式的Servlet容器自动配置

```java
@Configuration(
    proxyBeanMethods = false
)
@AutoConfigureOrder(-2147483648)
@ConditionalOnClass({ServletRequest.class})
@ConditionalOnWebApplication(
    type = Type.SERVLET
)
@EnableConfigurationProperties({ServerProperties.class})
@Import({ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.class, EmbeddedTomcat.class, EmbeddedJetty.class, EmbeddedUndertow.class})
//导入BeanPostProcessorsRegistrar：Spring注解版，给容器中导入一些组件
/**
 * 导入了WebServerFactoryCustomizerBeanPostProcessor：
 *	后置处理器：bean初始化前后（创建完对象，还没赋值）执行初始化工作
 */
public class ServletWebServerFactoryAutoConfiguration {
    
}

//上面ServletWebServerFactoryAutoConfiguration在注解@Import中导入了这个类
@Configuration(
    proxyBeanMethods = false
)
@ConditionalOnClass({Servlet.class, Tomcat.class, UpgradeProtocol.class})//判断当前是否引入了tomcat
@ConditionalOnMissingBean(
    value = {ServletWebServerFactory.class},
    search = SearchStrategy.CURRENT
)//判断当前容器没有用户自己定义 ServletWebServerFactory ：嵌入式的Servlet容器工厂。作用：创建嵌入式的Servlet容器
public static class EmbeddedTomcat {
    public EmbeddedTomcat() {
    }

    @Bean
    public TomcatServletWebServerFactory tomcatServletWebServerFactory(ObjectProvider<TomcatConnectorCustomizer> connectorCustomizers, ObjectProvider<TomcatContextCustomizer> contextCustomizers, ObjectProvider<TomcatProtocolHandlerCustomizer<?>> protocolHandlerCustomizers) {
        TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory();
        factory.getTomcatConnectorCustomizers().addAll((Collection)connectorCustomizers.orderedStream().collect(Collectors.toList()));
        factory.getTomcatContextCustomizers().addAll((Collection)contextCustomizers.orderedStream().collect(Collectors.toList()));
        factory.getTomcatProtocolHandlerCustomizers().addAll((Collection)protocolHandlerCustomizers.orderedStream().collect(Collectors.toList()));
        return factory;
    }
}
```

#### 1、ServletWebServerFactory（嵌入式Servlet容器工厂）

```java
@FunctionalInterface
public interface ServletWebServerFactory {
    
    //获取嵌入式的 Servlet 容器
    WebServer getWebServer(ServletContextInitializer... initializers);
}
```

![image-20200110152313406](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20200110152313406.png)

#### 2、WebServer：嵌入式的Servlet容器

![image-20200110152613623](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20200110152613623.png)

#### 3、以**TomcatServletWebServerFactory**为例

```java
public WebServer getWebServer(ServletContextInitializer... initializers) {
    if (this.disableMBeanRegistry) {
        Registry.disableRegistry();
    }

    //创建一个Tomcat
    Tomcat tomcat = new Tomcat();
    
    //配置Tomcat的基本环节
    File baseDir = this.baseDirectory != null ? this.baseDirectory : this.createTempDir("tomcat");
    tomcat.setBaseDir(baseDir.getAbsolutePath());
    Connector connector = new Connector(this.protocol);
    connector.setThrowOnFailure(true);
    tomcat.getService().addConnector(connector);
    this.customizeConnector(connector);
    tomcat.setConnector(connector);
    tomcat.getHost().setAutoDeploy(false);
    this.configureEngine(tomcat.getEngine());
    Iterator var5 = this.additionalTomcatConnectors.iterator();

    while(var5.hasNext()) {
        Connector additionalConnector = (Connector)var5.next();
        tomcat.getService().addConnector(additionalConnector);
    }

    this.prepareContext(tomcat.getHost(), initializers);
    
    //将配置好的tomcat传入进去，返回一个WebServer，并且启动Tomcat服务器
    return this.getTomcatWebServer(tomcat);
}
```

#### 4、我们对嵌入式容器的配置修改是怎么生效？

ServerProperties

WebServerFactoryCustomizer：定制器帮我们修改了Servlet容器的配置

#### 5、容器中导入了 **WebServerFactoryCustomizerBeanPostProcessor**

```java
//初始化之前
public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
    //如果当前初始化的是一个WebServerFactory类型的组件
    if (bean instanceof WebServerFactory) {
        
        this.postProcessBeforeInitialization((WebServerFactory)bean);
    }

    return bean;
}

private void postProcessBeforeInitialization(WebServerFactory webServerFactory) {
    //获取所有的定制器，调用每一个定制器的customize方法来给Servlet容器进行属性赋值
    ((Callbacks)LambdaSafe.callbacks(WebServerFactoryCustomizer.class, this.getCustomizers(), webServerFactory, new Object[0]).withLogger(WebServerFactoryCustomizerBeanPostProcessor.class)).invoke((customizer) -> {
        customizer.customize(webServerFactory);
    });
}

private Collection<WebServerFactoryCustomizer<?>> getCustomizers() {
    if (this.customizers == null) {
        //从容器中获取所有这个类型的组件 WebServerFactoryCustomizer
        //订制Servlet容器，可以给容器中添加一个 WebServerFactoryCustomizer 类型的组件
        this.customizers = new ArrayList(this.getWebServerFactoryCustomizerBeans());
        this.customizers.sort(AnnotationAwareOrderComparator.INSTANCE);
        this.customizers = Collections.unmodifiableList(this.customizers);
    }

    return this.customizers;
}

private Collection<WebServerFactoryCustomizer<?>> getWebServerFactoryCustomizerBeans() {
    return this.beanFactory.getBeansOfType(WebServerFactoryCustomizer.class, false, false).values();
}


ServerProperties也是定制器
```

步骤：

1. SpringBoot根据导入的依赖情况，给容器中添加相应的 ServletWebServerFactory 【TomcatServletWebServerFactory】

1. 容器中某个组件要创建对象就会惊动后置处理器：WebServerFactoryCustomizerBeanPostProcessor

   只要是嵌入式的Servlet容器工厂，后置处理器就工作

1. 后置处理器，从容器中获取所有的**WebServerFactoryCustomizer**，调用定制器的定制器方法

### 5、嵌入式Servlet容器启动原理

什么时候创建嵌入式的Servlet容器工厂？什么时候获取嵌入式的Servlet容器并启动Tomcat

获取嵌入式的Servlet容器工厂

1. SpringBoot应用启动运行run方法

1. this.refreshContext(context)，SpringBoot刷新IOC容器【创建IOC容器，并初始化容器，创建容器中的每一个组件】

1. refresh(context)刷新刚才创建好的 IOC 容器

   ```java
   public void refresh() throws BeansException, IllegalStateException {
       Object var1 = this.startupShutdownMonitor;
       synchronized(this.startupShutdownMonitor) {
           this.prepareRefresh();
           ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory();
           this.prepareBeanFactory(beanFactory);
   
           try {
               this.postProcessBeanFactory(beanFactory);
               this.invokeBeanFactoryPostProcessors(beanFactory);
               this.registerBeanPostProcessors(beanFactory);
               this.initMessageSource();
               this.initApplicationEventMulticaster();
               this.onRefresh();
               this.registerListeners();
               this.finishBeanFactoryInitialization(beanFactory);
               this.finishRefresh();
           } catch (BeansException var9) {
               if (this.logger.isWarnEnabled()) {
                   this.logger.warn("Exception encountered during context initialization - cancelling refresh attempt: " + var9);
               }
   
               this.destroyBeans();
               this.cancelRefresh(var9);
               throw var9;
           } finally {
               this.resetCommonCaches();
           }
   
       }
   }
   ```

   

1. onRefreash()：web的ioc容器重写了onRefresh方法

1. webioc容器会创建嵌入式的Servlet容器

1. 获取嵌入式的Servlet容器工厂

1. 使用容器工厂获取嵌入式的Servlet容器

1. 嵌入式的Servlet容器创建并启动Servlet

   先启动嵌入式的Servlet容器，再将ioc容器中剩下的没有创建出的对象获取出来

   ioc容器启动创建嵌入式的Servlet容器





## 9、使用外置的Servlet容器

嵌入式Servlet容器：

- 优点：简单、便携
- 缺点：默认不支持JSP、优化定制比较复杂（使用定制器【ServerProperties、自定义WebServerFactoryCustomizer】），自己编写嵌入式Servlet容器的创建工厂（【ServletWebServerFactory】）



外置的Servlet容器：外面安装Tomcat--应用war包的方式打包

步骤：

1. 必须创建war项目（利用idea创建好目录结构）

1. 将嵌入式的Tomcat指定为provided

   ```xml
   <dependency>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter-tomcat</artifactId>
       <scope>provided</scope>
   </dependency>
   ```

1. 必须编写一个**SpringBootServletInitializer**的子类，并调用configure方法

   ```java
   public class ServletInitializer extends SpringBootServletInitializer {
   
       @Override
       protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
           //传入SpringBoot应用的主程序
           return application.sources(SpringBoot04WebJspApplication.class);
       }
   
   }
   ```

1. 启动服务器就可以使用

    

   **<font size='5'>原理:</font>**

   jar包：执行SpringBoot主类的main方法，启动ioc容器，创建嵌入式的Servlet容器

   war包：启动服务器，**服务器启动SpringBoot应用**【SpringBootServletInitializer】，启动ioc容器

    

   Servlet3.0（Spring注解版）

   8.2.4 Shared libraries / runtimes pluggability

   规则：

   1. 服务器启动（web应用启动）会创建当前web应用里面每一个jar包里面        ServletContainerInitializer  实例

   1. ServletContainerInitializer的实现放在jar包的 META-INF/services 文件夹下，有一个名为 javax.servlet.ServletContainerInitializer 的文件，内容就是ServletContainerInitializer 实现类的全类名

   1. 还可以使用 @HandlesTypes，在容器启动的时候加载我们感兴趣的类：

       

   流程：

   1. 启动Tomcat

   1. org\springframework\spring-web\5.2.2.RELEASE\spring-web-5.2.2.RELEASE.jar!\META-INF\services\javax.servlet.ServletContainerInitializer

      Spring的web模块里面有这个文件：

      ```java
      org.springframework.web.SpringServletContainerInitializer
      ```

   1. SpringServletContainerInitializer将 @HandlesTypes({WebApplicationInitializer.class}) 标注的所有这个类型的类都传入到 onStartup 方法的 Set<Class<?>> ，为这些 WebApplicationInitializer 类型的类创建实例

   1. 每一个 WebApplicationInitializer 都调用自己的 onstartup 方法

      ![image-20200111202707513](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20200111202707513.png)

   1. 相当于我们的 SpringBootServletInitializer 的类会被创建对象，并执行 onStartup方法

   1. SpringBootServletInitializer 示例执行onStartup的时候会 createRootApplicationContext 创建容器

   ```java
   protected WebApplicationContext createRootApplicationContext(ServletContext servletContext) {
       //创建SpringApplicationBuilder
       SpringApplicationBuilder builder = this.createSpringApplicationBuilder();
       builder.main(this.getClass());
       ApplicationContext parent = this.getExistingRootWebApplicationContext(servletContext);
       if (parent != null) {
           this.logger.info("Root context already created (using as parent).");
           servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, (Object)null);
           builder.initializers(new ApplicationContextInitializer[]{new ParentContextApplicationContextInitializer(parent)});
       }
   
       builder.initializers(new ApplicationContextInitializer[]{new ServletContextApplicationContextInitializer(servletContext)});
       builder.contextClass(AnnotationConfigServletWebServerApplicationContext.class);
       
       //调用configure方法，子类重写了这个方法，将SpringBoot的主程序类传入了尽量
       builder = this.configure(builder);
       
       //使用builder创建一个Spring应用
       builder.listeners(new ApplicationListener[]{new SpringBootServletInitializer.WebEnvironmentPropertySourceInitializer(servletContext)});
       SpringApplication application = builder.build();
       if (application.getAllSources().isEmpty() && MergedAnnotations.from(this.getClass(), SearchStrategy.TYPE_HIERARCHY).isPresent(Configuration.class)) {
           application.addPrimarySources(Collections.singleton(this.getClass()));
       }
   
       Assert.state(!application.getAllSources().isEmpty(), "No SpringApplication sources have been defined. Either override the configure method or add an @Configuration annotation");
       if (this.registerErrorPageFilter) {
           application.addPrimarySources(Collections.singleton(ErrorPageFilterConfiguration.class));
       }
   
       //启动Spring应用
       return this.run(application);
   }
   ```

   7. Spring的应用就启动并且创建 IOC 容器

   ```java
   public ConfigurableApplicationContext run(String... args) {
       StopWatch stopWatch = new StopWatch();
       stopWatch.start();
       ConfigurableApplicationContext context = null;
       Collection<SpringBootExceptionReporter> exceptionReporters = new ArrayList();
       this.configureHeadlessProperty();
       SpringApplicationRunListeners listeners = this.getRunListeners(args);
       listeners.starting();
   
       Collection exceptionReporters;
       try {
           ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);
           ConfigurableEnvironment environment = this.prepareEnvironment(listeners, applicationArguments);
           this.configureIgnoreBeanInfo(environment);
           Banner printedBanner = this.printBanner(environment);
           context = this.createApplicationContext();
           exceptionReporters = this.getSpringFactoriesInstances(SpringBootExceptionReporter.class, new Class[]{ConfigurableApplicationContext.class}, context);
           this.prepareContext(context, environment, listeners, applicationArguments, printedBanner);
           
           //刷新IOC容器
           this.refreshContext(context);
           this.afterRefresh(context, applicationArguments);
           stopWatch.stop();
           if (this.logStartupInfo) {
               (new StartupInfoLogger(this.mainApplicationClass)).logStarted(this.getApplicationLog(), stopWatch);
           }
   
           listeners.started(context);
           this.callRunners(context, applicationArguments);
       } catch (Throwable var10) {
           this.handleRunFailure(context, var10, exceptionReporters, listeners);
           throw new IllegalStateException(var10);
       }
   
       try {
           listeners.running(context);
           return context;
       } catch (Throwable var9) {
           this.handleRunFailure(context, var9, exceptionReporters, (SpringApplicationRunListeners)null);
           throw new IllegalStateException(var9);
       }
   }
   ```

   启动Servlet容器，再启动SpringBoot应用





# 五、Docker

## 1、简介

Docker是一个开源的应用容器引擎

Docker支持将软件编译成一个镜像，然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像

运行中的这个镜像称为容器，容器启动时非常快的



## 2、核心概念

docker主机（Host）：安装了Docker程序的机器（Docker直接安装在操作系统之上）

docker客户端（Client）：连接docker主机进行操作

docker仓库（Registry）：用来保存各种打包好的软件镜像

docker镜像（Images）：软件打包好的镜像，放在docker仓库中

docker容器（Container）：镜像启动后的实例称为一个容器，容器时独立运行的一个或一组应用

使用Docker的步骤：

1. 安装Docker
1. 去Docker仓库找到这个软件对应的镜像
1. 使用Docker运行这个镜像，这个镜像就会生成一个Docker容器
1. 对容器的启动停止就是对软禁的启动停止



## 3、安装Docker

#### 1、安装Linux虚拟机

1. VMware、VirtualBox

1. 导入虚拟机文件 centos7-atguigu.ova

1. 双击linux虚拟机：使用 root/123456 登录

1. 使用客户端连接linux服务器

1. 设置虚拟机网络

   桥接网络 = 选好网卡 = 接入网线

1. 设置好网络以后使用命令重启虚拟机的网络

   ```shell
   service network restart
   ```

1. 查看linux的IP地址

   ```shell
   ip addr
   ```

1. 使用客户端连接：

#### 2、在Linux虚拟机上安装docker

步骤：

```shell
1.检查内核版本，必须是3.10及以上
uname -r
2.安装docker
yum install docker
3.输入y确定安装
4.启动docker
[root@bogon ~]# systemctl start docker
[root@bogon ~]# docker -v
Docker version 1.13.1, build 7f2769b/1.13.1
5.开机启动docker
[root@bogon ~]# systemctl enable docker
Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.
6.停止docker
[root@bogon ~]# 
```







## 4、Docker常用命令&操作

### 1、镜像操作

| 操作 | 命令                                        | 说明                                                    |
| ---- | ------------------------------------------- | ------------------------------------------------------- |
| 检索 | docker serach 关键字 eg:docker search redis | 我们经常去docker hub上检索镜像的详细信息，如镜像的TAG   |
| 拉取 | docker pull 镜像名 : tag                    | :tag是可取的，tag表示标签，多为软件的版本，默认是latest |
| 列表 | docker images                               | 查看所有的本地镜像                                      |
| 删除 | docker rmi image-id                         | 删除指定的本地镜像                                      |

<a>http://hub.docker.com</a>



### 2、容器操作

软件镜像（tomcat安装程序） --- 运行镜像 --- 产生一个容器（正在运行的软件，运行的tomcat）



步骤：

```shell
1.搜索镜像
[root@bogon ~]# docker search tomcat
2.拉取镜像
[root@bogon ~]# docker pull tomcat
3.根据镜像启动容器
[root@bogon ~]# docker run --name mytomcat -d tomcat:latest
4.查看运行中的容器
[root@bogon ~]# docker ps
5.停止运行中的容器
[root@bogon ~]# docker stop 容器的id
6.查看所有的容器
[root@bogon ~]# docker ps -a
7.启动容器
[root@bogon ~]# docker start 容器id
8.删除一个容器
[root@bogon ~]# docker rm 容器id
9.启动一个端口映射的tomcat
[root@bogon ~]# docker run -d -p 8888:8080 tomcat
	-d：后台运行
	-p:将主机的端口映射到容器的一个端口			主机端口：容器内部的端口
	
10.为了演示简单关闭了Linux的防火墙
[root@bogon ~]# service firewalld status：查看防火墙状态
[root@bogon ~]# service firewalld stop：关闭防火墙

# 更多命令查看：https://docs.docker.com/engine/reference/commandline/docker/
# 可以参考每个镜像的文档
```





### 3、安装MySQL示例

```shell
docker pull mysql
```



错误的启动

```shell
[root@localhost ~]# docker run --name mysql01 -d mysql
42f09819908bb72dd99ae19e792e0a5d03c48638421fa64cce5f8ba0f40f5846

mysql退出了
[root@localhost ~]# docker ps -a
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                           PORTS               NAMES
42f09819908b        mysql               "docker-entrypoint.sh"   34 seconds ago      Exited (1) 33 seconds ago                            mysql01
538bde63e500        tomcat              "catalina.sh run"        About an hour ago   Exited (143) About an hour ago                       compassionate_
goldstine
c4f1ac60b3fc        tomcat              "catalina.sh run"        About an hour ago   Exited (143) About an hour ago                       lonely_fermi
81ec743a5271        tomcat              "catalina.sh run"        About an hour ago   Exited (143) About an hour ago                       sick_ramanujan


//错误日志
[root@localhost ~]# docker logs 42f09819908b
error: database is uninitialized and password option is not specified 
  You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD；这个三个参数必须指定一个
```



正确的启动

```shell
[root@localhost ~]# docker run --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysql
2c71ad7bdd89a437362e1c04cb9e9965d9e06e4a11f4a1339cf39bfa0e14ee51
[root@localhost ~]# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                 NAMES
2c71ad7bdd89        mysql               "docker-entrypoint..."   8 seconds ago       Up 5 seconds        3306/tcp, 33060/tcp   mysql01

```

做了端口映射

```shell
[root@localhost ~]# docker run -p 3306:3306 --name mysql02 -e MYSQL_ROOT_PASSWORD=123456 -d mysql
b2db6c7cd50dfd2c21cab6d1da15940181b774737f5a6f774677ab205087b24d
[root@localhost ~]# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                               NAMES
b2db6c7cd50d        mysql               "docker-entrypoint..."   4 seconds ago       Up 4 seconds        0.0.0.0:3306->3306/tcp, 33060/tcp   mysql02
```



几个其他的高级操作

```shell
docker run --name mysql01 -v /conf/mysql:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag
把主机的/my/custom文件夹挂载到 mysqkdocker 容器的/etc/mysql/conf.d文件夹里面
文件文件改mysql的配置就只需要把mysql配置放在

docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci
指定mysql的一些参数
```







# 六、SpringBoot与数据访问

## 1、JDBC

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-jdbc</artifactId>
</dependency>
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <scope>runtime</scope>
</dependency>
```



```yaml
spring:
  datasource:
    username: root
    password: 123456
    url: jdbc:mysql://192.168.93.134:3306/jdbc
    driver-class-name: com.mysql.jdbc.Driver
```

效果：

		默认是用 com.zaxxer.hikari.HikariDataSource 作为数据源
	
		数据源的相关配置都在 DataSourceProperties 里面

自动配置原理：

		org.springframework.boot.autoconfigure.jdbc

1. 参考 DataSourceConfiguration ，默认是hikari，可以使用 spring.datasource.type 指定自定义的数据源类型

1. SpringBoot默认可以支持：

   - org.apache.tomcat.jdbc.pool.DataSource
   - HikariDataSource
   - BasicDataSource

1. 自定义数据源类型

   ```java
   //DataSourceConfiguration类中
   
   @Configuration(proxyBeanMethods = false)
   @ConditionalOnMissingBean(DataSource.class)
   @ConditionalOnProperty(name = "spring.datasource.type")
   static class Generic {
   
       @Bean
       DataSource dataSource(DataSourceProperties properties) {
           //使用DataSourceBuilder创建数据源，利用反射创建相应的type的数据源并且绑定相关属性
           return properties.initializeDataSourceBuilder().build();
       }
   
   }
   ```

1. DataSourceInitializerInvoker：ApplicationListener

   ```java
   @Configuration(proxyBeanMethods = false)
   @Import({ DataSourceInitializerInvoker.class, DataSourceInitializationConfiguration.Registrar.class })
   class DataSourceInitializationConfiguration {
   ```

   

   DataSourceInitializer类的作用：

   - runScripts（）：运行建表语句

   默认只需要将文件命名为：

   ```yaml
   schema-*.sql  data-*.sql
   默认规则：schema.sql、schema-all.sql
   可以使用：（指定文件名）
   	schema:
   	- classpath:deparment.sql
   ```

   目前版本需配置：

   ```yaml
   spring:
     datasource:
       username: root
       password: 123456
       url: jdbc:mysql://192.168.93.134:3306/jdbc
       driver-class-name: com.mysql.jdbc.Driver
       initialization-mode: always
       type: com.mysql.cj.jdbc.MysqlConnectionPoolDataSource
       schema: 
         - classpath:department.sql
   ```

1. 操作数据库：自动配置了jdbcTemplate



## 2、整合Druid数据源

```java
@Configuration
public class DruidConfig {

    @ConfigurationProperties(prefix = "spring.datasource")
    @Bean
    public DataSource druid(){
        return  new DruidDataSource();
    }

    //配置Druid的监控
    //1、配置一个管理后台的Servlet
    @Bean
    public ServletRegistrationBean statViewServlet(){
        ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), "/druid/*");
        Map<String,String> initParams = new HashMap<>();

        initParams.put("loginUsername","admin");
        initParams.put("loginPassword","123456");
        initParams.put("allow","");//默认就是允许所有访问
        initParams.put("deny","192.168.15.21");

        bean.setInitParameters(initParams);
        return bean;
    }


    //2、配置一个web监控的filter
    @Bean
    public FilterRegistrationBean webStatFilter(){
        FilterRegistrationBean bean = new FilterRegistrationBean();
        bean.setFilter(new WebStatFilter());

        Map<String,String> initParams = new HashMap<>();
        initParams.put("exclusions","*.js,*.css,/druid/*");

        bean.setInitParameters(initParams);

        bean.setUrlPatterns(Arrays.asList("/*"));

        return  bean;
    }
}
```



## 3、整合Mybatis

```xml
<dependency>
    <groupId>org.mybatis.spring.boot</groupId>
    <artifactId>mybatis-spring-boot-starter</artifactId>
    <version>2.1.1</version>
</dependency>
```



![image-20200116210716274](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20200116210716274.png)

步骤：

1. 配置数据源相关属性（见上一节Druid）
1. 给数据库建表
1. 创建JavaBean



### 1、注解版

```java
//指定这是一个操作数据库的mapper
@Mapper
@Component
public interface DepartmentMapper {

    @Select("select * from department where id=#{id}")
    public Department getDeptById(Integer id);

    @Delete("delete from department where id=#{id}")
    public int deleteDeptById(Integer id);

    @Options(useGeneratedKeys = true,keyProperty = "id")
    @Insert("insert into department(departmentName) values(#{departmentName})")
    public int insertDept(Department department);

    @Update("update department set departmentName=#{departmentName} where id=#{id}")
    public int updateDept(Department department);

}
```

问题：

自定义Mybatis的配置规则：给容器中添加一个 ConfigurationCustomizer

```java
@org.springframework.context.annotation.Configuration
public class MybatisConfig {

    public ConfigurationCustomizer configurationCustomizer(){
        return new ConfigurationCustomizer(){
            @Override
            public void customize(Configuration configuration) {
                configuration.setMapUnderscoreToCamelCase(true);
            }
        };
    }
}
```



```java
//使用MapperScan批量扫描所有的Mapper接口
@MapperScan(value = "com.atguigu.springboot.mapper")
```



### 2、配置文件版

```yaml
mybatis:
  # 指定全局配置文件位置
  config-location: classpath:mybatis/mybatis-config.xml
  # 指定sql映射文件位置
  mapper-locations: classpath:mybatis/mapper/*.xml
```



## 4、整合SpringData JPA

[项目](E:\workspace\workspace-springboot\1\spring-boot-06-data-jpa)

### 1、SpringData 简介

Spring Data JPA 框架，主要针对的就是 Spring 唯一没有简化到的业务逻辑代码，至此，开发者连仅剩的实现持久层业务逻辑的工作都省了，唯一要做的，就只是声明持久层的接口，其他都交给 Spring Data JPA 来帮你完成！



### 2、整合SpringData JPA



需要导入的依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jdbc</artifactId>
</dependency>

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>

-----------------------------------------------------------------------
<!--导入此依赖可以代替上面两个-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-jooq</artifactId>
</dependency>
```



JPA:ORM（Object Relational Mapping）

1. 编写一个实体类（bean）和数据表进行映射，并且配置好映射关系

   ```java
   //配置JPA注解配置映射关系
   @Data
   @Entity                     //告诉JPA这个一个实体类（和数据表映射的类）
   @AllArgsConstructor
   @NoArgsConstructor
   @Table(name = "t_user")     //@Table来指定和哪个数据表对应，如果省略默认表名就是首字母小写的类名
   public class User {
   
       @Id         //主键
       @GeneratedValue(strategy = GenerationType.IDENTITY)     //自增主键
       private Long id;
   
       @Column(name = "last_name", nullable = false, unique = true)    //这是和数据表对应的列，不为空且唯一
       private String username;
   
       @Column                     //省略则默认列名就是属性名
       private String password;
   
       public User(String username, String password) {
           this.username = username;
           this.password = password;
       }
   
   }
   ```

1. 编写一个Dao接口来操作实体类对应的数据表（Repository）

   ```java
   //继承JPARepository来完成对数据库的操作
   public interface UserRepository extends JpaRepository<User,Integer> {
   }
   ```

1. 基本的配置

   ```yaml
   spring:
     datasource:
       url: jdbc:mysql://localhost:3306/jpa?useUnicode=true&characterEncoding=utf-8&useSSL=true&serverTimezone=UTC
       driver-class-name: com.mysql.cj.jdbc.Driver
       username: root
       password: 1015
   
     jpa:
    hibernate:
         ddl-auto: update    # 更新或创建数据表结构
    database-platform: org.hibernate.dialect.MySQL5InnoDBDialect
       show-sql: true    # 控制台打印sql语句
   ```

# 七、启动配置原理

几个重要的事件回调机制

- ApplicationContextInitializer
- SpringApplicationRunListener
- ApplicationRunner
- CommandLineRunner



启动流程：

## 1、创建SpringApplication对象（==已过时==）

```java
initialize(sources);
private void initialize(Object[] sources) {
    //保存主配置类
    if (sources != null && sources.length > 0) {
        this.sources.addAll(Arrays.asList(sources));
    }
    //判断当前是否一个web应用
    this.webEnvironment = deduceWebEnvironment();
    //从类路径下找到META-INF/spring.factories配置的所有ApplicationContextInitializer；然后保存起来
    setInitializers((Collection) getSpringFactoriesInstances(
        ApplicationContextInitializer.class));
    //从类路径下找到ETA-INF/spring.factories配置的所有ApplicationListener
    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));
    //从多个配置类中找到有main方法的主配置类
    this.mainApplicationClass = deduceMainApplicationClass();
}
```



## 2、运行run方法

```java
public ConfigurableApplicationContext run(String... args) {
   StopWatch stopWatch = new StopWatch();
   stopWatch.start();
   ConfigurableApplicationContext context = null;
   FailureAnalyzers analyzers = null;
   configureHeadlessProperty();
    
   //获取SpringApplicationRunListeners；从类路径下META-INF/spring.factories
   SpringApplicationRunListeners listeners = getRunListeners(args);
    //回调所有的获取SpringApplicationRunListener.starting()方法
   listeners.starting();
   try {
       //封装命令行参数
      ApplicationArguments applicationArguments = new DefaultApplicationArguments(
            args);
      //准备环境
      ConfigurableEnvironment environment = prepareEnvironment(listeners,
            applicationArguments);
       		//创建环境完成后回调SpringApplicationRunListener.environmentPrepared()；表示环境准备完成
       
      Banner printedBanner = printBanner(environment);
       
       //创建ApplicationContext；决定创建web的ioc还是普通的ioc
      context = createApplicationContext();
       
      analyzers = new FailureAnalyzers(context);
       //准备上下文环境;将environment保存到ioc中；而且applyInitializers()；
       //applyInitializers()：回调之前保存的所有的ApplicationContextInitializer的initialize方法
       //回调所有的SpringApplicationRunListener的contextPrepared()；
       //
      prepareContext(context, environment, listeners, applicationArguments,
            printedBanner);
       //prepareContext运行完成以后回调所有的SpringApplicationRunListener的contextLoaded（）；
       
       //s刷新容器；ioc容器初始化（如果是web应用还会创建嵌入式的Tomcat）；Spring注解版
       //扫描，创建，加载所有组件的地方；（配置类，组件，自动配置）
      refreshContext(context);
       //从ioc容器中获取所有的ApplicationRunner和CommandLineRunner进行回调
       //ApplicationRunner先回调，CommandLineRunner再回调
      afterRefresh(context, applicationArguments);
       //所有的SpringApplicationRunListener回调finished方法
      listeners.finished(context, null);
      stopWatch.stop();
      if (this.logStartupInfo) {
         new StartupInfoLogger(this.mainApplicationClass)
               .logStarted(getApplicationLog(), stopWatch);
      }
       //整个SpringBoot应用启动完成以后返回启动的ioc容器；
      return context;
   }
   catch (Throwable ex) {
      handleRunFailure(context, listeners, analyzers, ex);
      throw new IllegalStateException(ex);
   }
}
```

## 3、事件监听机制

配置在META/spring.factories

**ApplicationContextInitializer**

```java
public class HelloApplicationContextInitializer implements ApplicationContextInitializer<ConfigurableApplicationContext> {
    @Override
    public void initialize(ConfigurableApplicationContext configurableApplicationContext) {
        System.out.println("ApplicationContextInitializer...initialize"+configurableApplicationContext);
    }
}
```

**SpringApplicationRunListener**

```java
public class HelloSpringApplicationRunListener implements SpringApplicationRunListener {

    public HelloSpringApplicationRunListener(SpringApplication application,String[] args){

    }

    @Override
    public void starting() {
        System.out.println("SpringApplicationRunListener...starting");
    }

    @Override
    public void environmentPrepared(ConfigurableEnvironment environment) {
        Object o = environment.getSystemProperties().get("os.name");
        System.out.println("SpringApplicationRunListener...environmentPrepared"+o);
    }

    @Override
    public void contextPrepared(ConfigurableApplicationContext context) {
        System.out.println("SpringApplicationRunListener...contextPrepared");
    }

    @Override
    public void contextLoaded(ConfigurableApplicationContext context) {
        System.out.println("SpringApplicationRunListener...contextLoaded");
    }

    @Override
    public void started(ConfigurableApplicationContext context) {
        System.out.println("SpringApplicationRunListener...started");
    }

    @Override
    public void running(ConfigurableApplicationContext context) {
        System.out.println("SpringApplicationRunListener...running");
    }

    @Override
    public void failed(ConfigurableApplicationContext context, Throwable exception) {
        System.out.println("SpringApplicationRunListener...failed");
    }
}
```

只需要放在ioc容器中

**ApplicationRunner**

```java
@Component
public class HelloApplicationRunner implements ApplicationRunner {
    @Override
    public void run(ApplicationArguments args) throws Exception {
        System.out.println("ApplicationRunner...run");
    }
}
```

**CommandLineRunner**

```java
@Component
public class HelloCommandLineRunner implements CommandLineRunner {
    @Override
    public void run(String... args) throws Exception {
        System.out.println("CommandLineRunner...run..."+ Arrays.asList(args));
    }
}
```







# 八、自定义starter

starter：

1. 这个场景需要使用到的依赖是什么？
1. 如何编写自动配置

```java
@Configuration		//指定这个类是一个配置类
@ConditionalOnXXX	//在指定条件成立的情况下自动配置类生效
@AutoConfigureAfter	//指定自动配置类的顺序
@Bean				//给容器中添加组件

@ConfigurationProperties结合相关xxxProperties类来绑定相关的配置
@EnableConfigurationProperties	//让xxxProperties生效加入到容器中
    
自动配置类要能加载
将需要启动就加载的自动配置类，配置在META-INF/spring.factories
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\
org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\
```

3. 模式

启动器只用来做依赖导入

专门来写一个自动配置模块

启动器依赖自动配置，别人只需要引入启动器（starter）

-mybatis-spring-boot-starter，自定义启动器后缀名：-spring-boot-starter





# 九、补充

安全问题

在web开发中，安全第一位！过滤器，拦截器~

功能性需求：否

做网站：安全应该什么时候考虑？设计之初！

- 漏洞，隐私泄露
- 架构一旦确定~



shiro、SpringSecurity：很像~除了类不一样，名字不一样

认证、授权



- 功能权限
- 访问权限
- 菜单权限
- … 拦截器，过滤器：大量的原生代码——冗余



MVC—Spring—SpringBoot—框架思想





## 1、Spring Security

**简介**

`SpringSecurity ` 是针对 `Spring` 项目的安全框架，也是 `SpringBoot` 的底层安全模块默认的技术选型，他可以实现强大的 Web 安全控制，对于安全控制，我们仅需要引入 `spring-boot-starter-security` 模块，进行少量的配置，即可实现强大的安全管理！

记住几个类：

- `WebSecurityConfigurerAdapter`：自定义 `Security` 策略
- `AuthenticationManagerBuilder`：自定义认证策略
- `@EnableWebSecurity`：开启 `WebSecurity` 模式

`Spring Security` 的两个主要目标是 "认证" 和 "授权"（访问控制）

"认证"（Authentication）

"授权"（Authorization）

这个概念是通用的，而不是只在 `Spring Security` 中存在

[官方文档](https://spring.io/projects/spring-security#overview)



[项目](E:\workspace\workspace-springboot\1\spring-boot-09-security-kuang)

### 1、SpringSecurity 环境搭建

需要导入的依赖：

```xml
<!--security-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>

<!--web-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>

<!--
	需要映射到页面上进行显示，所以引入的thymeleaf
-->
<!--thymeleaf-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-thymeleaf</artifactId>
</dependency>
```

关闭 `thymeleaf` 的缓存

```yaml
spring:
  thymeleaf:
    cache: false
```



### 2、用户的认证和授权

[官网地址](https://docs.spring.io/spring-security/site/docs/5.3.1.RELEASE/reference/html5/#jc)

```java
//AOP：拦截器
@EnableWebSecurity
public class RoleConfig extends WebSecurityConfigurerAdapter {

    //链式编程
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        //首页所有人可以访问，功能页只有对应有权限的人才能访问
        //请求授权的规则
        http.authorizeRequests()
                .antMatchers("/").permitAll()
                .antMatchers("/level1/**").hasRole("vip1")
                .antMatchers("/level2/**").hasRole("vip2")
                .antMatchers("/level3/**").hasRole("vip3");

        //没有权限默认会到登录页面，需要开启登录的页面
        http.formLogin().successForwardUrl("/index");

        //开启，注销功能，跳到首页
        http.csrf().disable();      //关闭crsf功能
        http.logout().logoutSuccessUrl("/index");

    }


    //认证
    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {

        //从内存中获取
        //使用 BCryptPasswordEncoder 类加密
        auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())
                .withUser("cyy").password(new BCryptPasswordEncoder().encode("123456")).roles("vip2", "vip3").and()
                .withUser("root").password(new BCryptPasswordEncoder().encode("123456")).roles("vip1", "vip2", "vip3");

    }
}
```

当客户端密码报错时，新版本的 `Spring Security` 需要加上加密方式，需要找一个继承 `PasswordEncoder` 接口的子类即可。



### 3、注销及权限控制

让不同角色权限的用户显示不同权限的信息：

目前：新版本的 `SpringBoot` 不支持这种方式，需要将版本调回 `2.0.9.RELEASE`



在页面上显示不同权限的信息，需要导入 `thymeleaf` 和 `security` 的组合包

```xml
<dependency>
    <groupId>org.thymeleaf.extras</groupId>
    <artifactId>thymeleaf-extras-springsecurity4</artifactId>
    <version>3.0.4.RELEASE</version>
</dependency>
```



当未登录时显示 `登录` 按钮，登录后显示 `用户名` 和 `注销` 按钮

```html
<!--登录注销-->
<div class="right menu">

    <!--未登录-->
    <div sec:authorize="!isAuthenticated()">
        <a class="item" th:href="@{/login}">
            <i class="address card icon"></i> 登录
        </a>
    </div>

    <!--如果登录：显示用户名、注销-->
    <div sec:authorize="isAuthenticated()">
        <a class="item">
            用户名：<span sec:authentication="name"></span>
        </a>
    </div>
    <div sec:authorize="isAuthenticated()">
        <a class="item" th:href="@{/logout}">
            <i class="sign out icon"></i> 注销
        </a>
    </div>
    
</div>
```



不同的内容设置不同的权限

```html
<div class="column" sec:authorize="hasRole('vip1')">
<div class="ui raised segment">
    <div class="ui">
        <div class="content">
            <h5 class="content">Level 1</h5>
            <hr>
            <div><a th:href="@{/level1/1}"><i class="bullhorn icon"></i> Level-1-1</a></div>
            <div><a th:href="@{/level1/2}"><i class="bullhorn icon"></i> Level-1-2</a></div>
            <div><a th:href="@{/level1/3}"><i class="bullhorn icon"></i> Level-1-3</a></div>
        </div>
    </div>
</div>
</div>

<div class="column" sec:authorize="hasRole('vip2')">
<div class="ui raised segment">
    <div class="ui">
        <div class="content">
            <h5 class="content">Level 2</h5>
            <hr>
            <div><a th:href="@{/level2/1}"><i class="bullhorn icon"></i> Level-2-1</a></div>
            <div><a th:href="@{/level2/2}"><i class="bullhorn icon"></i> Level-2-2</a></div>
            <div><a th:href="@{/level2/3}"><i class="bullhorn icon"></i> Level-2-3</a></div>
        </div>
    </div>
</div>
</div>
```



### 4、记住我及登录页订制

配置类中：

```java
//订制登录页
//username和password的参数需要对应传的name
http.formLogin().loginPage("/toLogin").usernameParameter("username").passwordParameter("pwd");

//没有权限默认会到登录页面，需要开启登录的页面
http.formLogin().successForwardUrl("/index");

//开启记住我功能，cookie默认保存两周，自定义接收前端的参数，name属性值要对应
http.rememberMe().rememberMeParameter("remember");
```



## 2、Shiro

### 1、什么是Shiro？

- `Apache Shiro` 是一个Java的安全（权限）框架
- `Shiro` 可以非常容易的开发出足够好的应用，其不仅可以用在JavaSE环境，也可以用在JavaEE环境
- `Shiro` 可以完成认证、授权、加密、会话管理、Web集成，缓存等。
- 下载地址：http://shiro.apache.org/
- ![image-20200403090448092](F:\Typora\images\image-20200403090448092.png)



### 2、有哪些功能

![image-20200403134029041](F:\Typora\images\image-20200403134029041.png)

- Authentication：身份认证、登录，验证用户是不是拥有对应的身份
- Authorization：授权，即权限验证，验证某个已认证的用户是否拥有某个权限，即判断用户能否进行什么操作；如：验证某个用户是否拥有某个角色，或者细粒度的验证某个角色对某个资源是否具有某个权限
- Session Manager：会话管理，即用户登录后及时第一次会话，在没有退出之前，它的所有信息都在会话中，会话可以是普通的JavaSE环境，也可以是web环境
- Cryptography：加密，保护数据的安全性，如密码加密存储到数据库中，而不是明文存储
- Web Support：web支持，可以非常容易的集成到web环境
- Caching：缓存，比如用户登录后，其用户信息，拥有的角色、授权不必每次去查，这样可以提高效率
- Concurrency：Shiro支持多线程应用的并发验证，即，如在一个线程中开启另一个线程，能把权限自动的传播过去
- Testing：提供测试支持
- Run As：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问
- Remember Me：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了



### 3、Shiro架构（外部）

从外部来看Shiro，即从应用程序角度来观察如何使用shiro完成工作：

![image-20200403135602062](F:\Typora\images\image-20200403135602062.png)

- **subject**：应用代码直接交互的对象是 `Subject` ，也就是说 `Shiro` 的对外API核心就是 `Subject`，`Subject` 代表了当前的用户，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是 `Subject`，如网络爬虫、机器人等，与 `Subject` 的所有交互都会委托给 `SecurityManager` ；`Subject` 其实是一个门面，`SecurityManager` 才是实际的执行者。
- **SecurityManager**：安全管理器，即所有与安全相关的操作都会与 `SecurityManager` 交互，并且它管理者所有的 `Subject` ，可以看出它是 `Shiro` 的核心，它负责与 `Shiro` 的其他组件进行交互，它相当于 `SpringMVC` 的 `DispatcherServlet` 的角色
- **Realm**：`Shiro` 从 `Realm` 获取安全数据（如用户、角色、权限），就是说 `SecurityManager` 要验证用户身份，那么它需要从 `Realm` 获取相应的角色进行比较，来确定用户的身份是否合法，也需要从 `Realm` 得到用户相应的额角色、权限，进行验证用户的操作是否能够进行，可以把 `Realm` 看成 `DataSource`

![image-20200403141110146](F:\Typora\images\image-20200403141110146.png)

- Subject：任何可以与应用交互的 ‘用户’
- Security Manager：相当于 `SpringMvc` 中的 `DispatcherServlet`，是 `Shiro` 的心脏，所有具体的交互都通过 `Security Manager` 进行控制，它管理着所有的 `Subject` ，且负责进行认证，授权，会话，及缓存的管理
- Authenticator：负责 `Subject` 认证，是一个扩展点，可以自定义实现；可以使用认证策略（Authentication Strategy），即什么情况下算用户认证通过了
- Authorizer：授权器，即访问控制器，用来决定主体是否有权限进行相应的操作；即控制着用户能访问应用中的哪些功能
- Realm：可以有一个或者多个 `realm`，可以认为是安全实体数据源，即用于获取安全实体的，可以用 JDBC 实现，也可以是内存实现等等，由用户提供，所以一般在应用中都需要实现自己的 `realm`
- SessionManager：管理 `Session` 生命周期的组件，而 `Shiro` 并不仅仅可以用在 web 环境，也可以用在普通的JavaSE环境中
- CacheManager：缓存控制器，来管理如用户、角色、权限等缓存的，因为这些数据基本上很少改变，放到缓存中可以提高访问的性能
- Cryptography：密码模块，Shiro提高了一些常见的加密组件用于密码加密，解密等



### 4、快速开始

[项目](E:\workspace\workspace-springboot\1\spring-boot-09-shiro-kuang\Security-01-hello)

直接从 [GitHub](https://github.com/apache/shiro) 上下载源码，里面有 `shiro-master\samples\quickstart` 快速开始示例

1. 导入依赖

   ```xml
   <dependency>
       <groupId>org.apache.shiro</groupId>
       <artifactId>shiro-core</artifactId>
       <version>1.5.2</version>
   </dependency>
   
   <!-- configure logging日志 -->
   <dependency>
       <groupId>org.slf4j</groupId>
       <artifactId>jcl-over-slf4j</artifactId>
       <version>1.7.30</version>
   </dependency>
   <dependency>
       <groupId>org.slf4j</groupId>
       <artifactId>slf4j-log4j12</artifactId>
       <version>1.7.30</version>
   </dependency>
   <dependency>
       <groupId>log4j</groupId>
       <artifactId>log4j</artifactId>
       <version>1.2.17</version>
   </dependency>
   ```

2. 配置文件

   ```ini
   [users]
   # user 'root' with password 'secret' and the 'admin' role
   root = secret, admin
   # user 'guest' with the password 'guest' and the 'guest' role
   guest = guest, guest
   # user 'presidentskroob' with password '12345' ("That's the same combination on
   # my luggage!!!" ;)), and role 'president'
   presidentskroob = 12345, president
   # user 'darkhelmet' with password 'ludicrousspeed' and roles 'darklord' and 'schwartz'
   darkhelmet = ludicrousspeed, darklord, schwartz
   # user 'lonestarr' with password 'vespa' and roles 'goodguy' and 'schwartz'
   lonestarr = vespa, goodguy, schwartz
   
   # -----------------------------------------------------------------------------
   # Roles with assigned permissions
   #
   # Each line conforms to the format defined in the
   # org.apache.shiro.realm.text.TextConfigurationRealm#setRoleDefinitions JavaDoc
   # -----------------------------------------------------------------------------
   [roles]
   # 'admin' role has all permissions, indicated by the wildcard '*'
   admin = *
   # The 'schwartz' role can do anything (*) with any lightsaber:
   schwartz = lightsaber:*
   # The 'goodguy' role is allowed to 'drive' (action) the winnebago (type) with
   # license plate 'eagle5' (instance specific id)
   goodguy = winnebago:drive:eagle5
   ```

3. HelloWorld

   ```java
   public class Quickstart {
   
       private static final transient Logger log = LoggerFactory.getLogger(Quickstart.class);
   
       public static void main(String[] args) {
   
           Factory<SecurityManager> factory = new IniSecurityManagerFactory("classpath:shiro.ini");
           SecurityManager securityManager = factory.getInstance();
           SecurityUtils.setSecurityManager(securityManager);
   
           //获取当前的用户对象 Subject
           Subject currentUser = SecurityUtils.getSubject();
   
           // 通过当前用户拿到 Session
           Session session = currentUser.getSession();
           session.setAttribute("someKey", "aValue");
           String value = (String) session.getAttribute("someKey");
           if (value.equals("aValue")) {
               log.info("Retrieved the correct value! [" + value + "]");
           }
   
           // 判断当前用户是否被认证
           if (!currentUser.isAuthenticated()) {
   
               //token：令牌
               UsernamePasswordToken token = new UsernamePasswordToken("lonestarr", "vespa");
               token.setRememberMe(true);      //设置记住我
               try {
                   currentUser.login(token);   //执行登录操作
               } catch (UnknownAccountException uae) {      //未知账户
                   log.info("There is no user with username of " + token.getPrincipal());
               } catch (IncorrectCredentialsException ice) {       //密码错误
                   log.info("Password for account " + token.getPrincipal() + " was incorrect!");
               } catch (LockedAccountException lae) {          //用户锁定
                   log.info("The account for username " + token.getPrincipal() + " is locked.  " +
                           "Please contact your administrator to unlock it.");
               }
               // ... catch more exceptions here (maybe custom ones specific to your application?
               catch (AuthenticationException ae) {
                   //unexpected condition?  error?
               }
           }
   
           //say who they are:
           //print their identifying principal (in this case, a username):
           log.info("User [" + currentUser.getPrincipal() + "] logged in successfully.");
   
           //test a role:
           if (currentUser.hasRole("schwartz")) {      //测试角色
               log.info("May the Schwartz be with you!");
           } else {
               log.info("Hello, mere mortal.");
           }
   
           //粗粒度
           //test a typed permission (not instance-level)
           if (currentUser.isPermitted("lightsaber:wield")) {
               log.info("You may use a lightsaber ring.  Use it wisely.");
           } else {
               log.info("Sorry, lightsaber rings are for schwartz masters only.");
           }
   
           //细粒度
           //a (very powerful) Instance Level permission:
           if (currentUser.isPermitted("winnebago:drive:eagle5")) {
               log.info("You are permitted to 'drive' the winnebago with license plate (id) 'eagle5'.  " +
                       "Here are the keys - have fun!");
           } else {
               log.info("Sorry, you aren't allowed to drive the 'eagle5' winnebago!");
           }
   
           //all done - log out!
           currentUser.logout();       //注销
   
           //注销
           System.exit(0);
       }
   }
   ```

**【运行结果】：**

![image-20200403185419310](F:\Typora\images\image-20200403185419310.png)



### 5、SpringBoot整合Shiro

创建一个SpringBoot项目

[项目](E:\workspace\workspace-springboot\1\spring-boot-09-shiro-kuang\shiro-02-springboot)

1. 导入依赖

```xml
<!--
    Subject             用户
    SecurityManager     管理所有的用户
    Realm               连接数据
-->
<!--Shiro整合Spring的包-->
<dependency>
    <groupId>org.apache.shiro</groupId>
    <artifactId>shiro-spring</artifactId>
    <version>1.5.2</version>
</dependency>

<!--web-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>

<!--thymeleaf-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-thymeleaf</artifactId>
</dependency>
```

2. 编写配置

```java
//自定义的 UserRealm
public class UserRealm extends AuthorizingRealm {

    //授权
    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {
        System.out.println("执行了授权方法=>principalCollection");
        return null;
    }

    //认证
    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {
        System.out.println("执行了认证方法=>authenticationToken");
        return null;
    }
}
```

```java
@Configuration
public class ShiroConfig {

    //ShiroFilterFactoryBean
    @Bean
    public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier("securityManager") DefaultWebSecurityManager manager){
        ShiroFilterFactoryBean factoryBean = new ShiroFilterFactoryBean();
        //设置安全管理器
        factoryBean.setSecurityManager(manager);
        return factoryBean;
    }

    //DefaultWebSecurityManager
    @Bean(name = "securityManager")
    public DefaultWebSecurityManager getDefaultWebSecurityManager(@Qualifier("userRealm") UserRealm userRealm){
        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();
        //关联UserRealm
        securityManager.setRealm(userRealm);
        return securityManager;
    }

    //创建 realm 对象
    @Bean
    public UserRealm userRealm(){
        return new UserRealm();
    }

}
```



#### 1、拦截

在配置中设置拦截

- anno：无需认证就可以访问
- authc：必须认证了才能访问
- user：必须拥有 记住我 功能才能访问
- perms：拥有对某个资源的权限才能访问
- role：拥有某个角色资源才能访问

在 `ShiroFilterFactoryBean` 组件中设置访问拦截

```java
//ShiroFilterFactoryBean
@Bean
public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier("securityManager") DefaultWebSecurityManager manager) {
    ShiroFilterFactoryBean factoryBean = new ShiroFilterFactoryBean();
    //设置安全管理器
    factoryBean.setSecurityManager(manager);

    /*
        anno：无需认证就可以访问
        authc：必须认证了才能访问
        user：必须拥有 记住我 功能才能访问
        perms：拥有对某个资源的权限才能访问
        role：拥有某个角色资源才能访问
     */

    //登录拦截
    Map<String, String> filterMap = new LinkedHashMap<>();

    filterMap.put("/user/add", "authc");
    filterMap.put("/user/update", "authc");

    factoryBean.setFilterChainDefinitionMap(filterMap);

    factoryBean.setLoginUrl("/toLogin");

    return factoryBean;
}
```



#### 2、用户认证

在用户类中虚拟出用户名和密码

```java
//认证
@Override
protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {
    System.out.println("执行了认证方法=>authenticationToken");

    //用户名、密码    数据库中取
    String name = "root";
    String password = "123456";

    UsernamePasswordToken userToken = (UsernamePasswordToken) token;

    if (!userToken.getUsername().equals(name)) {
        return null;        //异常抛出  UnknownAccountException
    }

    //密码认证，shiro做~
    return new SimpleAuthenticationInfo("", password, "");
}
```



### 6、shiro整合mybatis

1. 导入依赖

```xml
<!--log4j-->
<dependency>
    <groupId>log4j</groupId>
    <artifactId>log4j</artifactId>
    <version>1.2.17</version>
</dependency>

<!--druid-->
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid</artifactId>
    <version>1.1.21</version>
</dependency>

<!--jdbc-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jdbc</artifactId>
</dependency>

<!--mybatis-->
<dependency>
    <groupId>org.mybatis.spring.boot</groupId>
    <artifactId>mybatis-spring-boot-starter</artifactId>
    <version>2.1.2</version>
</dependency>

<!--mysql-->
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
</dependency>
```

2. 配置文件

   在 `application.yml ` 进行数据库的连接

```yaml
spring:
  datasource:
    username: root
    password: 1015
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/shiro?useUnicode=true&characterEncoding=utf-8&serverTimezone=UTC
    type: com.alibaba.druid.pool.DruidDataSource
```

		在 `application.properties` 中配置 `mybatis` 连接配置

```properties
mybatis.type-aliases-package=com.cyy.pojo
mybatis.mapper-locations=classpath:mapper/*.xml
```

3. 配置对应的 `mapper` 层、`service` 层
4. 在用户 `UserRealm` 类中进行密码校验

```java
//自定义的 UserRealm
public class UserRealm extends AuthorizingRealm {

    @Autowired
    UserService userService;

    //认证
    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {
        System.out.println("执行了认证方法=>authenticationToken");

        UsernamePasswordToken userToken = (UsernamePasswordToken) token;

        //连接数据库
        User user = userService.queryByName(userToken.getUsername());

        if (user == null) {
            return null;        //异常抛出  UnknownAccountException
        }

        //密码认证，shiro做~
        return new SimpleAuthenticationInfo("", user.getPassword(), "");
    }
}
```



#### 1、请求授权

在配置类中对请求设置相应的权限

```java
//ShiroFilterFactoryBean
@Bean
public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier("securityManager") DefaultWebSecurityManager manager) {
    ShiroFilterFactoryBean factoryBean = new ShiroFilterFactoryBean();
    //设置安全管理器
    factoryBean.setSecurityManager(manager);

    /*
        anno：无需认证就可以访问
        authc：必须认证了才能访问
        user：必须拥有 记住我 功能才能访问
        perms：拥有对某个资源的权限才能访问
        role：拥有某个角色资源才能访问
     */

    //拦截
    Map<String, String> filterMap = new LinkedHashMap<>();

    //授权
    filterMap.put("/user/add", "perms[user:add]");
    filterMap.put("/user/update", "perms[user:update]");

    //filterMap.put("/user/*", "authc");
    factoryBean.setFilterChainDefinitionMap(filterMap);

    //没有登录的请求
    factoryBean.setLoginUrl("/toLogin");
    //未授权页面
    factoryBean.setUnauthorizedUrl("/noauth");

    return factoryBean;
}
```

从数据库中查询用户的权限

```java
//自定义的 UserRealm
public class UserRealm extends AuthorizingRealm {

    @Autowired
    UserService userService;

    //授权
    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {
        System.out.println("执行了授权方法=>principalCollection");

        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();
        info.addStringPermission("user:add");

        //拿到当前登录的这个对象
        Subject subject = SecurityUtils.getSubject();
        User currentUser = (User) subject.getPrincipal();

        //设置当前用户的权限
        info.addStringPermission(currentUser.getPerms());

        return info;
    }

    //认证
    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {
        System.out.println("执行了认证方法=>authenticationToken");

        UsernamePasswordToken userToken = (UsernamePasswordToken) token;

        //连接数据库
        User user = userService.queryByName(userToken.getUsername());

        if (user == null) {
            return null;        //异常抛出  UnknownAccountException
        }

        //密码认证，shiro做~
        return new SimpleAuthenticationInfo(user, user.getPassword(), "");
    }
}
```

通过名字从数据库中进行查找

```java
//自定义的 UserRealm
public class UserRealm extends AuthorizingRealm {

    @Autowired
    UserService userService;

    //授权
    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {
        System.out.println("执行了授权方法=>principalCollection");

        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();
        //info.addStringPermission("user:add");     给没有权限的添加权限

        //拿到当前登录的这个对象
        Subject subject = SecurityUtils.getSubject();
        User currentUser = (User) subject.getPrincipal();

        //设置当前用户的权限
        info.addStringPermission(currentUser.getPerms());

        return info;
    }

    //认证
    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {
        System.out.println("执行了认证方法=>authenticationToken");

        UsernamePasswordToken userToken = (UsernamePasswordToken) token;

        //连接数据库
        User user = userService.queryByName(userToken.getUsername());

        if (user == null) {
            return null;        //异常抛出  UnknownAccountException
        }

        Subject currentSubject = SecurityUtils.getSubject();
        Session session = currentSubject.getSession();
        session.setAttribute("loginUser", user);

        //密码认证，shiro做~
        return new SimpleAuthenticationInfo(user, user.getPassword(), "");
    }
}
```

在页面上显示不同权限的请求

1. 导入 shiro-thymeleaf 的整合依赖包

```xml
<!--shiro-thymeleaf整合-->
<dependency>
    <groupId>com.github.theborakompanioni</groupId>
    <artifactId>thymeleaf-extras-shiro</artifactId>
    <version>2.0.0</version>
</dependency>
```

2. 在页面中引入 shiro 标签

```html
xmlns:shiro="http://www.pollix.at/thymeleaf/shiro"
```

```html
<div shiro:hasPermission="user:add">
    <a th:href="@{/user/add}">add</a>
</div>

<div shiro:hasPermission="user:update">
    <a th:href="@{/user/update}">update</a>
</div>
```





## 3、Swagger

学习目标：

- 了解 `Swagger` 的作用和概念
- 了解前后端分离
- 在 `SpringBoot` 中集成 `Swagger`



### 1、Swagger简介

**前后端分离**

Vue + SpringBoot

后端时代：前端只用管理静态页面，html –> 后端，模板引擎 JSP —–>后端是主力



前后端分离时代：

- 后端：后端控制层，服务层，数据访问层【后端团队】
- 前端：前端控制层，视图层【前端团队】
  - 伪造后端数据，json。已经存在了，不需要后端，前端工程依旧能够跑起来
- 前后端如何交互 —>  API
- 前后端相对独立，松耦合
- 前后端甚至可以部署在不同的服务器上



产生一个问题：

- 前后端集成联调，前端人员和后端人员无法做到 "及时协商，尽早解决"，最终导致问题集中爆发

解决方案：

- 首先指定 schema[计划的提纲]，实时更新最新 API，降低集成的风险
- 早些年：指定 word 计划文档
- 前后端分离：
  - 前端测试后端接口：postman
  - 后端提供接口，需要实时更新最新的消息及改动



### 2、Swagger

- 号称世界上最流行的 API 框架
- RestFul API文档在线自动生成工具 –> API文档与API定义同步更新
- 直接运行，可以在线测试 API 接口
- 支持多种语言：（Java、PHP……）

[官网](https://swagger.io/)



在项目中使用 Swagger 需要 springbox

- swagger2
- ui



### 3、SpringBoot集成Swagger



1. 新建一个 SpringBoot -web项目
2. 导入相关的依赖

```xml
<dependency>
    <groupId>io.springfox</groupId>
    <artifactId>springfox-swagger2</artifactId>
    <version>2.9.2</version>
</dependency>
<dependency>
    <groupId>io.springfox</groupId>
    <artifactId>springfox-swagger-ui</artifactId>
    <version>2.9.2</version>
</dependency>
```

3. 编写一个 Hello World 工程
4. 配置 Swagger –> Config

```java
@Configuration
@EnableSwagger2     //开启 Swagger2
public class SwaggerConfig {

}
```

5. 测试运行：http://localhost:8080/swagger-ui.html

![image-20200406111632624](F:\Typora\images\image-20200406111632624.png)



### 4、配置 Swagger 信息

```java
@Configuration
@EnableSwagger2     //开启 Swagger2
public class SwaggerConfig {

    @Bean
    public Docket getDocket(){
        return new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(getApiInfo());
    }

    private ApiInfo getApiInfo(){

        //作者信息
        Contact contact = new Contact("cyy","localhost:8080/hello","576779239@qq.com");

        return new ApiInfo(
                "Cyy的API",
                "一直有梦想的咸鱼",
                "1.1",
                "urn:tos",
                contact,
                "Apache 2.0",
                "http://www.apache.org/licenses/LICENSE-2.0",
                new ArrayList());
    }
}
```

配置的信息可以直接在页面上显示

![image-20200406114000664](F:\Typora\images\image-20200406114000664.png)



### 5、Swagger 配置扫描接口

```java
@Bean
public Docket getDocket(){
    return new Docket(DocumentationType.SWAGGER_2)
            .apiInfo(getApiInfo())
            .select()
            /*
                RequestHandlerSelectors，配置要扫描接口的方式
                basePackage：指定要扫描的包
                any()：扫描全部
                none()：不扫描
                withClassAnnotation：扫描类上的注解，参数是一个注解的反射对象
                withMethodAnnotation：扫描方法上的注解
             */
            .apis(RequestHandlerSelectors.basePackage("com.cyy.swagger.controller"))
            //paths()：过滤什么路径
            .paths(PathSelectors.ant("/cyy/*"))
            .build();
}
```

配置是否启动 Swagger

```java
@Bean
public Docket getDocket(){
    return new Docket(DocumentationType.SWAGGER_2)
            .apiInfo(getApiInfo())
            //enable是否启动Swagger，如果为false，则Swagger不能在浏览器中访问
            .enable(false);
}
```

设置项目 `Swagger` 在生产环境中使用，在发布的时候不使用：

```java
@Bean
public Docket getDocket(Environment environment){

    //设置要显示的 Swagger 环境
    Profiles profiles = Profiles.of("dev", "test");

    //通过 environment.acceptsProfiles 判断是否处在自己设定的环境当中
    boolean flag = environment.acceptsProfiles(profiles);

    return new Docket(DocumentationType.SWAGGER_2)
            .apiInfo(getApiInfo())
            //enable是否启动Swagger，如果为false，则Swagger不能在浏览器中访问
            .enable(flag);
}
```



配置API文档的分组

```java
.groupName("cyy")
```

如何配置多个分组，多个 `Docket` 实例即可

```java
@Bean
public Docket docket1(){
    return new Docket(DocumentationType.SWAGGER_2).groupName("A");
}

@Bean
public Docket docket2(){
    return new Docket(DocumentationType.SWAGGER_2).groupName("B");
}

@Bean
public Docket docket3(){
    return new Docket(DocumentationType.SWAGGER_2).groupName("C");
}
```



实体类配置

```java
@ApiModel("用户实体类")
public class User implements Serializable {

    @ApiModelProperty("用户名")
    public String username;
    @ApiModelProperty("密码")
    public String password;
}
```

```java
//只要我们的接口中，返回值中存在实体类，它就会被扫描到 Swagger 中
@PostMapping("/user")
public User user() {
    return new User();
}
```

![image-20200406143943235](F:\Typora\images\image-20200406143943235.png)





总结：

1. 我们可以通过 `Swagger` 给一些比较难理解的属性或者接口，增加注释信息
2. 接口文档实时更新
3. 可以在线测试

Swagger 是一个优秀的工具



【注意点】在正式发布的时候，关闭 Swagger !!! 出于安全考虑，而且节省运行的内存。
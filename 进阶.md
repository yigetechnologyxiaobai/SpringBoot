# 一、Spring Boot与缓存

## 1、Spring缓存抽象

Spring从3.1开始定义了 org.springframework.cache.Cache 和 org.springframework.cache.CacheManager接口来同一个不同的缓存技术，并支持使用 JCache（JSR-107）注解简化我们开发

- Cache接口为缓存的组件规范定义，包含缓存的各种操作集合

- Cache接口下Spring提供了各种xxxCache的实现，如：RedisCache、EhCacheCache、ConcurrentMapCache等

- 每次调用需要缓存功能的方法时，Spring会检查检查指定参数的指定的目标方法是否已经被调用过；如果有就直接从缓存中获取方法调用后的结果，如果没有就调用方法并缓存结果后返回给用户。下次调用直接从缓存中获取

- 使用Spring缓存抽象时我们需要关注以下两点：

  1. 确定方法需要被缓存以及他们的缓存策略

  1. 从缓存中读取之前缓存存储的数据

     ![image-20200122163741248](F:\Typora\images\image-20200122163741248.png)

## 2、几个重要的概念和缓存注解

| Cache          | 缓存接口，定义缓存操作。实现有：RedisCache、EhCacheCache、ConcurrentMapCache等 |
| -------------- | ------------------------------------------------------------ |
| CacheManager   | 缓存管理器，管理各种缓存（Cache）组件                        |
| @Cacheable     | 主要针对方法配置，能够根据方法的请求参数对其结果进行缓存     |
| @CacheEvict    | 清空缓存                                                     |
| @CachePut      | 保证方法被调用，又希望结果被缓存                             |
| @EnableCaching | 开启基于注解的缓存                                           |
| keyGenerator   | 缓存数据时key生成策略                                        |
| serialize      | 缓存数据时value序列化策略                                    |

@Cacheable/@CachePut/@CacheEvict 主要的参数

![image-20200122212225427](F:\Typora\images\image-20200122212225427.png)

![image-20200122212250400](F:\Typora\images\image-20200122212250400.png)

示例：

### 1、搭建环境

#### 1、导入数据库文件，创建出department和employee表

![image-20200122185215279](F:\Typora\images\image-20200122185215279.png)

#### 2、创建javabean封装数据

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class User {

    private Integer id;
    private String name;
    private Integer age;
    private String sex;

    public User(String name, Integer age, String sex) {
        this.name = name;
        this.age = age;
        this.sex = sex;
    }
}
```

#### 3、整合Mybatis操作数据库

1、配置数据源信息

```properties
spring.datasource.url=jdbc:mysql://localhost:3306/eesy?useUnicode=true&characterEncoding=utf-8&serverTimezone=UTC
spring.datasource.username=root
spring.datasource.password=1015
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# 开启驼峰命名规则
mybatis.configuration.map-underscore-to-camel-case=true

# 显示sql日志信息
logging.level.com.atguigu.cache.mapper=debug

debug=true
```

2、使用注解版的Mybatis

@MapperScan指定需要扫描的mapper接口所在的包（在主类上）

```java
@Mapper
@Component
public interface UserMapper {

    @Select("select * from user")
    public List<User> queryAll();

    @Select("select * from user where id = #{id}")
    public User queryById(Integer id);

    @Update("update user set name=#{name},age=#{age},sex=#{sex} where id=#{id}")
    public void updateUser(User user);

    @Delete("delete from user where id = #{id}")
    public void deleteUser(Integer id);

    @Insert("insert into user (name,age,sex) values(#{name},#{age},#{sex})")
    public void insertUser();

}
```

### 2、体验缓存

#### 1、开启基于注解的缓存(@EnableCaching)

```java
/**
 * 一、搭建基本环境
 *  1、导入数据库文件，创建出department和employee表
 *  2、创建javabean封装数据
 *  3、整合Mybatis操作数据库
 *      1、配置数据源信息
 *      2、使用注解版的Mybatis：
 *          1、@MapperScan指定需要扫描的mapper接口所在的包
 * 二、快速体验缓存
 *  步骤：
 *      1、开启基于注解的缓存
 *      2、标注缓存注解即可
 *           @Cacheable
 *           @CacheEvict
 *           @CachePut
 */
@SpringBootApplication
@EnableCaching
@MapperScan("com.cyy.redis.mapper")
public class SpringbootRedisApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringbootRedisApplication.class, args);
    }

}
```

#### 2、标注缓存注解即可

##### 1、@Cacheable注解

Cacheable：将方法的运行结果进行缓存，以后再要相同的数据，直接从缓存中获取，不用调用方法

CacheManager管理多个Cache组件，对缓存的真正CRUD操作在Cache组件中，每一个缓存组件由自己唯一一个名字



###### 1、原理：

1. 自动配置类：CacheAutoConfiguration

1. 缓存的配置类

   ```java
   org.springframework.boot.autoconfigure.cache.GenericCacheConfiguration
   org.springframework.boot.autoconfigure.cache.JCacheCacheConfiguration
   org.springframework.boot.autoconfigure.cache.EhCacheCacheConfiguration
   org.springframework.boot.autoconfigure.cache.HazelcastCacheConfiguration
   org.springframework.boot.autoconfigure.cache.InfinispanCacheConfiguration
   org.springframework.boot.autoconfigure.cache.CouchbaseCacheConfiguration
   org.springframework.boot.autoconfigure.cache.RedisCacheConfiguration
   org.springframework.boot.autoconfigure.cache.CaffeineCacheConfiguration
   org.springframework.boot.autoconfigure.cache.SimpleCacheConfiguration
   org.springframework.boot.autoconfigure.cache.NoOpCacheConfiguration
   ```

3. 那个配置类生效？    `SimpleCacheConfiguration`
3. 给容器中注册了一个 `CacheManager`：`ConcurrentMapCacheManager`
3. 可以获取和创建 `ConcurrentMapCache` 类型的缓存组件，它的作用将数据保存在 `ConcurrentMap` 中

###### 2、@Cacheable运行流程：

1. 方法运行之前，先去查询Cache（缓存组件），按照cacheNames指定的名字获取（CacheManager先获取相应的缓存），第一次获取缓存 如果没有Cache组件会自动创建

1. 去Cache中查找缓存的内容，使用一个key，默认就是方法的参数key是按照某种策略去生成，默认是使用keyGenerator生成的，默认使用SimpleKeyGenerator生成key

   		SimpleKeyGenerator生成key的默认策略：
      				如果没有参数：key=new SimpleKey()
      				如果有一个参数：key=参数的值
          			  如果有多个参数：key=new SimpleKey(params);

1. 没有查到缓存就调用目标方法

1. 将目标方法返回的结果，放进缓存中



==@Cacheable方法执行之前先来检查缓存中有没有这个数据，默认按照参数的值作为key去查询缓存，如果没有就运行方法并将结果放进缓存中,以后再来调用就可以直接使用缓存中的数据==



###### 3、核心：

1. 使用CacheManager【ConcurrentMapCacheManager】按照名字得到Cache【ConcurrentMapCache】组件
1. key使用keyGenerator生成的，默认是SimpleKeyGenerator

###### 4、属性：

- cacheNames/values：指定缓存组件的名字，将方法的返回结果放在哪个缓存中，是数组的方式，可以指定多个缓存

- key：缓存数据使用的key，可以用它来指定，默认是使用方法参数的值， 1-方法的返回值
               编写SpEL: #id，参数id的值     #a0  #p0  #root.args[0]

- keyCenerator：key的生成器，可以自己指定key的生成器的组件id

       <font color='red' size='4'>key/keyGenerator二选一使用</font>

- cacheManager：指定缓存管理器，或者cacheResolver指定获取解析器

- condition：指定符合条件的情况下才缓存
          condition = "#a0>1"，第一个参数的值 > 1 的时候进行缓存
      
- unless：否定缓存，当unless指定的条件为true，方法的返回值就不会被缓存，获取到结果进行判断
                   unless = "#result == null"
                   unless = "a0==2"：如果第一个参数的值是2，结果不缓存
      
- sync：是否使用异步模式

```java
@Service
public class UserService {

    @Autowired
    private UserMapper userMapper;

    @Cacheable(cacheNames = "user", keyGenerator = "myKeyGenerator",
            condition = "#id>0", unless = "#id==3")
    public User queryUserById(Integer id) {
        return userMapper.queryById(id);
    }

}
```

keyGenerator = "myKeyGenerator"，指定生成器的组件id

```java
@Configuration
public class MyCacheConfig {

    @Bean("myKeyGenerator")
    public KeyGenerator keyGenerator() {
        return new KeyGenerator() {
            @Override
            public Object generate(Object target, Method method, Object... params) {
                return method.getName() + "[" + Arrays.asList(params) + "]";
            }
        };
    }

}
```



##### 2、@CachePut注解

@CachePut 既调用方法，又更新数据，修改了数据库的某个数据，同时更新缓存。

###### 1、运行时机：

1. 先调用目标方法
1. 将目标方法的结果缓存起来



###### 2、测试步骤：

1. 查询1号员工，查到的结果会放在缓存中              

   		key：1 			 value：lastName：詹姆斯

1. 以后查询还是之前的结果

1. 更新1号员工：【lastName：库里，gender=0】

   			将方法的返回值也放进缓存中

      			key：传入的employee对象  值：返回的employee对象*      

1. 查询1号员工？

   		应该是更新后的员工

      		key = "#employee.id"：使用传入的参数的员工id

      		key = "#result.id"：使用返回后的id

      					@Cacheable的key是不能用#result      

   为什么是没更新的？【1号员工没有在缓存中更新】

```java
@Service
public class UserService {

    @CachePut(value = "emp")
    public Employee updateEmp(Employee employee){
        System.out.println("updateEmp..."+employee);
        employeeMapper.updateEmp(employee);
        return employee;
    }
}
```

想要将缓存中对应的数据更新，缓存中的key的值需要对应相同

```java
@Service
public class UserService {

    @CachePut(value = "user", key = "user.id")
    public void updateUser(User user) {
        userMapper.updateUser(user);
    }
}
```



##### 3、@CacheEvict注解

@CacheEvict：缓存清除

###### 属性：

- key：指定要清除的数据

- allEntries = false/true：是否清除缓存中所有的数据

- beforeInvocation

  - = false：缓存的清除是否在方法之前执行

    默认代表缓存清除操作是在方法执行之后执行，如果出现异常缓存就不会清除

  - = true：

    代表清除缓存操作是在方法执行之前执行，无论方法是否出现异常，缓存都清除

```java
@Service
public class UserService {

   	@CacheEvict(value = "user", key = "#id",beforeInvocation = true)
    public void deleteUser(Integer id) {
        userMapper.deleteUser(id);
    }
}
```



##### 4、@Caching注解

@Caching 定义复杂的缓存规则

```java
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
public @interface Caching {
    Cacheable[] cacheable() default {};

    CachePut[] put() default {};

    CacheEvict[] evict() default {};
}
```

```java
@Service
public class UserService {

   @Caching(
            cacheable = {
                    @Cacheable(value = "user", key = "#name")
            },
            put = {
                    @CachePut(value = "user", key = "#result.id"),
                    @CachePut(value = "user", key = "#result.name")
            }
    )
    public User queryUserByName(String name) {
        return userMapper.queryByName(name);
    }
}
```



##### 5、@CacheConfig

对类的配置，里面的方法也会含有

抽取缓存的公共配置

```java
@Service
@CacheConfig(cacheNames = "emp")
public class UserService {

	@CachePut(value = "user", key = "user.id")	//类上配置之后，方法上不用配置
    public void updateUser(User user) {
        userMapper.updateUser(user);
    }
}
```



### 3、使用redis

使用 linux 上的docker安装 redis

#### 1、下载redis镜像

```shell
docker pull redis
```

#### 2、开启redis

```shell
docker run -d -p 6379:6379 --name myredis redis
```

#### 3、使用 redis Desktop Manager 应用进行连接

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20200127155223592.png" alt="image-20200127155223592" style="zoom:50%;" />

redis的命令：http://redis.cn/commands.html

#### 4、测试redis

application.properties 配置文件中需要配置

```properties
# 默认端口号为 6379
spring.redis.host=192.168.248.128
```

```xml
<!-- 导入redis的依赖 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```

```java
//redis的默认自动配置类，含有两个组件
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass(RedisOperations.class)
@EnableConfigurationProperties(RedisProperties.class)
@Import({ LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class })
public class RedisAutoConfiguration {

	@Bean
	@ConditionalOnMissingBean(name = "redisTemplate")
	public RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory)
			throws UnknownHostException {
		RedisTemplate<Object, Object> template = new RedisTemplate<>();
		template.setConnectionFactory(redisConnectionFactory);
		return template;
	}

	@Bean
	@ConditionalOnMissingBean
	public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory)
			throws UnknownHostException {
		StringRedisTemplate template = new StringRedisTemplate();
		template.setConnectionFactory(redisConnectionFactory);
		return template;
	}

}
```

##### 1、测试保存数据

```java
@SpringBootTest
class SpringbootRedisApplicationTests {

    @Autowired
    private UserMapper userMapper;

    @Autowired
    private StringRedisTemplate stringRedisTemplate;        //操作k-v都是字符串的

    /**
     * Redis常见的五大数据类型
     * String（字符串）、List（列表）、Set（集合）、Hash（散列）、ZSet（有序集合）
     * stringRedisTemplate.opsForValue()       [String（字符串）]
     * stringRedisTemplate.opsForList()        [List（列表）]
     * stringRedisTemplate.opsForSet()         [Set集合]
     * stringRedisTemplate.opsForHash()        [Hash（散列）]
     * stringRedisTemplate.opsForZSet()        [ZSet（有序集合）]
     */
    @Test
    void set() {
        stringRedisTemplate.opsForValue().append("msg", "hello");
        stringRedisTemplate.opsForList().leftPush("mylist", "1");
        stringRedisTemplate.opsForList().leftPush("mylist", "2");
    }

    @Test
    void get() {
        String msg = stringRedisTemplate.opsForValue().get("msg");
        System.out.println(msg);
        String mylist = stringRedisTemplate.opsForList().leftPop("mylist");
        System.out.println(mylist);
    }
}
```

##### 2、测试保存对象

对象需要序列化

```java
public class User implements Serializable {
```

```java
@SpringBootTest
class Springboot01CacheApplicationTests {
 
    @Autowired
    EmployeeMapper employeeMapper;
    
    @Autowired
    RedisTemplate redisTemplate;        //k-v都是对象的
    
    /**
     * 测试保存对象
     */
    @Test
    public void test02(){
        Employee employee = employeeMapper.getEmpById(1);
        //默认如果保存对象，使用jdk序列化机制，序列化后的数据保存到redis中
        redisTemplate.opsForValue().set("emp-01",employee);
    }
}
```

```java
//因为默认是 jdk的序列化器
if (this.defaultSerializer == null) {
        this.defaultSerializer = new JdkSerializationRedisSerializer(this.classLoader != null ? this.classLoader : this.getClass().getClassLoader());
}
```

测试效果

![image-20200127171554390](F:\Typora\images\image-20200127171554390.png)



可以使用json的方式进行数据保存

```java
//自己写序列化器，改用Jackson2JsonRedisSerializer序列化器
@Configuration
public class MyRedisConfig {

    @Bean
    public RedisTemplate<Object, Employee> empRedisTemplate(
            RedisConnectionFactory redisConnectionFactory){
        RedisTemplate<Object,Employee> template = new RedisTemplate<Object, Employee>();
        template.setConnectionFactory(redisConnectionFactory);
        Jackson2JsonRedisSerializer<Employee> serializer = new Jackson2JsonRedisSerializer<Employee>(Employee.class);
        template.setDefaultSerializer(serializer);
        return template;
    }
}
```

```java
@SpringBootTest
class Springboot01CacheApplicationTests {
 
    @Autowired
    EmployeeMapper employeeMapper;
    
    @Autowired
    RedisTemplate<Object,Employee> empRedisTemplate;
    
    /**
     * 测试保存对象
     */
    @Test
    public void test02(){
        Employee employee = employeeMapper.getEmpById(1);

        /**
         * 1.将数据以json的方式保存
         *  (1)自己将对象转为json
         *  (2)redisTemplate默认的序列化规则,改变默认的序列化规则
         */
        empRedisTemplate.opsForValue().set("emp-01",employee);
    }
}
```

以json来保存数据

![image-20200127172307924](F:\Typora\images\image-20200127172307924.png)





# 二、SpringBoot与消息

## 1、AMQP

**AMQP 是什么？**

AMQP（Advanced Message Queuing Protocol,高级消息队列协议）是一个进程间传递**异步消息**的**网络协议**



**AMQP模型**

![](F:\Typora\images\20181022113306601.png)

**工作过程**

发布者（Publisher）发布消息（Message），经由交换机（Exchange）。

交换机根据**路由规则**将收到的消息分发给与该交换机绑定的队列（Queue）。

最后 AMQP 代理会将消息投递给订阅了此队列的消费者，或者消费者按照需求自行获取



**深入理解**

1、发布者、交换机、队列、消费者都可以有多个。同时因为 AMQP 是一个网络协议，所以这个过程中的发布者，消费者，消息代理 可以分别存在于不同的设备上。

2、发布者发布消息时可以给消息指定各种消息属性（Message Meta-data）。有些属性有可能会被消息代理（Brokers）使用，然而其他的属性则是完全不透明的，它们只能被接收消息的应用所使用。

3、从安全角度考虑，网络是不可靠的，又或是消费者在处理消息的过程中意外挂掉，这样没有处理成功的消息就会丢失。基于此原因，AMQP 模块包含了一个消息确认（Message Acknowledgements）机制：当一个消息从队列中投递给消费者后，不会立即从队列中删除，直到它收到来自消费者的确认回执（Acknowledgement）后，才完全从队列中删除。

4、在某些情况下，例如当一个消息无法被成功路由时（无法从交换机分发到队列），消息或许会被返回给发布者并被丢弃。或者，如果消息代理执行了延期操作，消息会被放入一个所谓的死信队列中。此时，消息发布者可以选择某些参数来处理这些特殊情况。





### 1、RabbitMQ中的交换机

#### 1、交换机的作用

我们通过队列发送和接收消息中，实际上里面还有一个重要的组合交换机。

在 `RabbitMq` 中，产生着不是直接将消息发送给消费者，产生者根本不知道这个消息要传递给哪些队列。实际上，产生者只是将消息发送给交换机。交换机收到消息后，根据交换机的类型和配置来处理消息，有如下几种情况：

- 将消息传送给特定的队列
- 有可能发送到多个队列中
- 也有可能丢弃消息



**RabbitMQ各个组件的功能归纳**：

- 产生者：发送消息
- 交换机：将收到的消息根据规则路由到特定队列
- 队列：用于存储消息
- 消费者：收到消息并消费



#### 2、交换机的类型

1. Direct exchange（直连交换机）
2. Fanout exchange（扇形交换机）
3. Topic exchange（主题交换机）
4. Header exchange（头交换机）

另外，RabbitMQ默认定义了一些交换机

- Default exchange（默认交换机）
- amq.* exchange

还有一类特殊的交换机：Dead Letter Exchange（死信交换机）



##### 1、Direct exchange（直连交换机）

bindings（绑定）、routingKey（路由键）

![image-20200410154006111](F:\Typora\images\image-20200410154006111.png)

`direct` 类型的 `exchange` 路由规则时：它会把消息路由到那些 `binding key` 与 `routing key` 完全匹配的 `Queue` 中。

`direct Exchange` 是 `RabbitMQ Broker` 的默认 `exchange` ，它有一个特别的属性对一些简单的应用来说是非常有用的，在使用这个类型的 `exchange` 时，可以不必指定 `routing key` 的名字，在此类型下创建的 `Queue` 有一个默认的 `routing key` ，这个 `routing key` 一般同 `Queue` 同名

`direct` 模式可以使用 `RabbitMQ` 自带的 `exchange`：`default exchange`。所以不需要将 `exchange` 进行任何(binding) 绑定。消息传递时，`RouteKey` 必须完全匹配，才会被队列接收，否则该消息会被抛弃。



##### 2、Fanout exchange（扇形交换机）

![image-20200410155157679](F:\Typora\images\image-20200410155157679.png)

任何发送到 **Fanout Exchange** 的消息都会被发送到与该 **Exchange** 绑定（Binding）的所有 **Queue** 上。

1. 这种模式不需要 `RouteKey`
2. 这种模式需要提前将 `Exchange` 与 `Queue` 进行绑定，一个 `Exchange` 可以绑定多个 `Queue`，一个`Queue` 可以同多个 `Exchange` 进行绑定
3. 如果接受到消息的 `Exchange` 没有与任何 `Queue` 绑定，则消息会被抛弃



##### 3、Topic exchange（主题交换机）

![image-20200410162346144](F:\Typora\images\image-20200410162346144.png)

**任何发送到 Topic Exchange 的消息都会被转发到所有关心 Route 中指定话题的 Queue 上**

1. 每个队列都有其关心的主题，所有的消息都带有一个“标题”(RouteKey)， `Exchange` 会将消息转发到所有关注主题能与 `RouteKey` 模糊匹配的队列
2. 这种模式需要 `RouteKey`，也许要提前绑定 `Exchange` 与 `Queue` 
3. 在进行绑定时，要提供一个该队列关心的主题，如 “#.log.#” 表示该队列关心所有涉及log的消息(一个RouteKey为”MQ.log.error”的消息会被转发到该队列)
4. 如果 `Exchange` 没有发现能够与 `RouteKey` 匹配的 `Queue` ，则会抛弃此消息

注："#" 表示0个或若干个关键字，"\*"表示一个关键字。如 “log.\* ”能与 “log.warn” 匹配，无法与 “log.warn.timeout” 匹配；但是“log.#”能与上述两者匹配

<img src="F:\Typora\images\image-20200128160405007.png" alt="image-20200128160405007" style="zoom:67%;" />

##### 4、Headers exchange（头交换机）

![img](F:\Typora\images\1794747-777bd2c9331f8271.webp)

headers类型的Exchange不依赖于routing key与binding key的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。

在绑定Queue与Exchange时指定一组键值对；当消息发送到Exchange时，RabbitMQ会取到该消息的headers（也是一个键值对的形式），对比其中的键值对是否完全匹配Queue与Exchange绑定时指定的键值对；如果完全匹配则消息会路由到该Queue，否则不会路由到该Queue。



交换时通过Headers头部来将消息映射到队列的，有点像HTTP的Headers，Hash结构中要求携带一个键“x-match”，这个键的Value可以是any或者all，这代表消息携带的Hash是需要全部匹配(all)，还是仅匹配一个键(any)就可以了。相比直连交换机，首部交换机的优势是匹配的规则不被限定为字符串(string)而是Object类型。

- any: 只要在发布消息时携带的有一对键值对headers满足队列定义的多个参数arguments的其中一个就能匹配上，注意这里是键值对的完全匹配，只匹配到键了，值却不一样是不行的
- all：在发布消息时携带的所有Entry必须和绑定在队列上的所有Entry完全匹配





消息队列（Message Queue，简称MQ），从字面意思上看，本质是个队列，FIFO先入先出，只不过队列中存放的内容是message而已。
		其主要用途：不同进程 `Process`/线程 `Thread` 之间通信。



### 2、RabbitMQ中的消息队列

**什么是消息队列？**

[详解文章](https://developer.51cto.com/art/201904/595020.htm)

我们可以把消息队列比作是一个存放消息的容器，当我们需要使用消息的时候可以取出消息供自己使用。消息队列是分布式系统中重要的组件，使用消息队列主要是为了通过异步处理提高系统性能和削峰、降低系统耦合性。目前使用的比较多的消息队列有ActiveMQ，RabbitMQ，Kafka，RocketMQ。

另外，我们知道队列 Queue 是一种先进先出的数据结构，所以消费消息时也是按照顺序来消费的。比如生产者发送消息1,2,3...对于消费者就会按照1,2,3...的顺序来消费。但是偶尔也会出现消息被消费的顺序不对的情况，比如某个消息消费失败又或者一个 queue 多个consumer 也会导致消息被消费的顺序不对，我们一定要保证消息被消费的顺序正确。



MQ框架非常之多，比较流行的有RabbitMq、ActiveMq、ZeroMq、kafka，以及阿里开源的RocketMQ。



**为什么要用消息队列？**

1.通过异步处理提高系统性能（削峰、减少响应所需时间

![img](F:\Typora\images\2509688-311483f18a8d228e.webp)

如上图，在不使用消息队列服务器的时候，用户的请求数据直接写入数据库，在高并发的情况下数据库压力剧增，使得响应速度变慢。但是在使用消息队列之后，用户的请求数据发送给消息队列之后立即 返回，再由消息队列的消费者进程从消息队列中获取数据，异步写入数据库。由于消息队列服务器处理速度快于数据库（消息队列也比数据库有更好的伸缩性），因此响应速度得到大幅改善。

通过以上分析我们可以得出**消息队列具有很好的削峰作用的功能**——即**通过异步处理，将短时间高并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务。** 举例：在电子商务一些秒杀、促销活动中，合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击。如下图所示：

<img src="F:\Typora\images\2509688-f9b9af2c6620e724.webp" alt="img" style="zoom:67%;" />

因为用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验、写数据库等操作中可能失败。因此使用消息队列进行异步处理之后，需要适当修改业务流程进行配合，比如用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功，以免交易纠纷。这就类似我们平时手机订火车票和电影票。



2.降低系统耦合性。



**使用消息队列产生的问题？**

- **系统可用性降低：** 系统可用性在某种程度上降低，为什么这样说呢？在加入MQ之前，你不用考虑消息丢失或者说MQ挂掉等等的情况，但是，引入MQ之后你就需要去考虑了！
- **系统复杂性提高：** 加入MQ之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题！
- **一致性问题：** 我上面讲了消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了!



![image-20200128160658017](F:\Typora\images\image-20200128160658017-1587781240515.png)



## 2、安装 Rabbitmq 和启动

```shell
docker pull rabbitmq:management		# 该版本包含了web控制页面
```

```shell
[root@localhost ~]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
rabbitmq            management          83a908d59456        5 hours ago         181MB

[root@localhost ~]# docker run -d -p 5672:5672 -p 15672:15672 --name myrabbitmq 83a908d59456
```

网址：http://192.168.10.128:15672      ip+默认端口号

用户和默认密码：guest

![这里写图片描述](F:\Typora\images\20180805224641957.png)





## 3、消息传输（代码实现）

### 1、环境搭建

#### 1、加入新的组件

![image-20200128160855635](F:\Typora\images\image-20200128160855635.png)

#### 2、代码实现

已经手动创建好特定的 exchange、Queue、Bind

```properties
spring.rabbitmq.host=192.168.248.128
spring.rabbitmq.username=guest
spring.rabbitmq.password=guest
# spring.rabbitmq.port=5672   默认是 5672
```

RabbitMQ的自动配置 

1. RabbitAutoConfiguration
1. 有自动配置了连接工厂ConnectionFactory
1. RabbitProperties 封装了 Rabbit 的配置
1. RabbitTemplate：给 RabbitMQ发送和接收消息
1. AmqpAdmin:RabbitMQ系统管理组件
1. @EnableRabbit + @RabbitListener 监听消息队列的内容

**单播发送**

```java
@SpringBootTest
class Springboot02AmqpApplicationTests {

    @Autowired
    RabbitTemplate rabbitTemplate;

    /**
     * 1、单播（点对点）
     * 
     * 发送消息
     */
    @Test
    void contextLoads() {
        //Message需要自己构造一个，定义消息体内容和消息头
        //rabbitTemplate.send(exchange,routeKey,message);

        //object默认当成消息体，只需要传入要发送的对象，自动序列化发送给rabbitmq
        //rabbitTemplate.send(exchange,routeKey,message);
        Map<String,Object> map = new HashMap<>();
        map.put("msg","这是第一个消息");
        map.put("data", Arrays.asList("helloworld",123,true));
        //对象被默认序列化以后发送出去
        rabbitTemplate.convertAndSend("exchange.direct","atguigu.news",map);
    }

    /**
     * 接收数据
     */
    @Test
    public void receive(){
        Object o = rabbitTemplate.receiveAndConvert("atguigu.news");
        System.out.println(o.getClass());
        System.out.println(o);
    }
}
```

消息队列中的消息：

![image-20200128170104159](F:\Typora\images\image-20200128170104159.png)

![image-20200128162312509](F:\Typora\images\image-20200128162312509.png)

因为它是默认的jdk的类型，我们也可以用json的方式

```java
//向容器中添加组件
@Configuration
public class MyAMQPConfig {

    @Bean
    public MessageConverter messageConverter(){
        return new Jackson2JsonMessageConverter();
    }
}
```

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20200128163148705.png" alt="image-20200128163148705" style="zoom:80%;" />

**广播发送**

```java
/**
 * 广播
 */
@Test
public void sendMsg(){
    rabbitTemplate.convertAndSend("exchange.direct","",new Book("三国演义","罗贯中"));
}
```

队列都接收到了

![image-20200128170549393](F:\Typora\images\image-20200128170549393.png)

每一个消息队列中含有相同的消息体

![image-20200128170636040](F:\Typora\images\image-20200128170636040.png)



## 4、消息监听

监听指定的消息队列

先要开启注解支持

```java
@EnableRabbit           //开启基于注解的RabbitMQ模式
@SpringBootApplication
public class Springboot02AmqpApplication {

    public static void main(String[] args) {
        SpringApplication.run(Springboot02AmqpApplication.class, args);
    }
}
```

```java
@Service
public class BookService {

    @RabbitListener(queues = "atguigu.news")
    public void receive(Book book){
        System.out.println("收到消息"+book);
    }

    @RabbitListener(queues = "atguigu")
    public void receive02(Message message){
        System.out.println(message.getBody());
        System.out.println(message.getMessageProperties());
    }
}
```



## 5、AmqpAdmin管理组件的使用

使用 AmqpAdmin 组件 可以创建、删除、绑定 Exchange、queue

```java
@SpringBootTest
class Springboot02AmqpApplicationTests {

    @Autowired
    AmqpAdmin amqpAdmin;
    
     @Test
    public void createExchange(){
        //创建exchange
        amqpAdmin.declareExchange(new DirectExchange("amqpadmin.exchange"));

        //创建queue，并持久化
        amqpAdmin.declareQueue(new Queue("amqpadmin.queue",true));

        //创建绑定规则
        amqpAdmin.declareBinding(new Binding("amqpadmin.queue",                Binding.DestinationType.QUEUE,"amqpadmin.exchange","amqp.haha",null));
    }
}
```







# 三、SpringBoot与检索

**简介：**

我们的应用经常需要添加检索功能，开源的 Elasticsearch 是目前全文搜索引擎的首选，他可以快速的存储、搜索和分析海量数据。SpringBoot通过整合Spring Data Elasticsearch 为我们提供了非常便捷的检索功能支持。

Elasticsearch 是一个分布式搜索服务，提供 Restful API，底层基于 Lucene，采用多 shard（分片）的方式保证数据安全，并且提供自动 resharding 的功能，GitHub 等大型的站点也是采用了 Elasticsearch 作为其搜索服务。



下载 elasticsearch 的镜像

```shell
# 下载镜像
[root@localhost ~]# docker pull elasticsearch

# 开启容器
[root@localhost ~]# docker run -e ES_JAVA_OPTS="-Xms256m -Xmx256m" -d -p 9200:9200 -p 9300:9300 --name ES01 elasticsearch
```

验证是否成功：	ip+端口号

![image-20200128202503073](F:\Typora\images\image-20200128202503073.png)

构建项目

![image-20200129134527903](F:\Typora\images\image-20200129134527903.png)

SpringBoot默认支持两种技术来和 elasticsearch 交互

## 1、Jest（默认不生效）

需要导入 jest 的工具包（io.searchbox.client.JestClient）

```xml
<!--需要注掉 Elasticsearch 的依赖-->
<dependency>
    <groupId>io.searchbox</groupId>
    <artifactId>jest</artifactId>
    <version>5.3.3</version>
</dependency>
```

```properties
spring.elasticsearch.jest.uris=http://192.168.248.128:9200
```

```java
public class Article {

    @JestId		//表明主键
    private Integer id;
    private String author;
    private String title;
    private String content;
    
    //get、set方法
}
```

```java
@SpringBootTest
class Springboot03ElasticApplicationTests {

    @Autowired	//JestAutoConfiguration中配置的组件
    JestClient jestClient;

    @Test
    void contextLoads() {
        //1、给ES中索引（保存）一个文档
        Article article = new Article();
        article.setId(1);
        article.setTitle("好消息");
        article.setAuthor("张三");
        article.setContent("Hello World");

        //构建一个索引功能
        Index index = new Index.Builder(article).index("atguigu").type("news").build();

        try {
            jestClient.execute(index);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    //测试搜索
    @Test
    public void search(){

        //查询表达式
        String json ="{\n" +
                "    \"query\" : {\n" +
                "        \"match\" : {\n" +
                "            \"content\" : \"hello\"\n" +
                "        }\n" +
                "    }\n" +
                "}";

        //构建搜索功能
        Search search = new Search.Builder(json).addIndex("atguigu").addType("news").build();

        //执行
        try {
            SearchResult result = jestClient.execute(search);
            System.out.println(result.getJsonString());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

![image-20200129134950326](F:\Typora\images\image-20200129134950326.png)



## 2、SpringData ElasticSearch

代码报错，尚未解决

1. Client 节点信息 clusterNodes ，clusterName
1. ElasticsearchTemplate操作 ElasticSearch
1. 编写一个 ElasticSearchRepository 的子接口来操作 ElasticSearch

```xml
<!--SpringBooy默认使用SpringData ElasticSearch模块进行操作-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-elasticsearch</artifactId>
</dependency>
```

```properties
spring.elasticsearch.jest.uris=http://192.168.248.128:9200

spring.data.elasticsearch.cluster-name=elasticsearch
spring.data.elasticsearch.cluster-nodes=192.168.248.128:9301
```

```java
@Document(indexName = "atguigu",type = "book")
public class Book {

    private Integer id;
    private String bookName;
    private String author;
    
    //get、set、toString方法
}
```

```java
//编写一个 ElasticSearchRepository 的子接口来操作 ElasticSearch
public interface BookRepository extends ElasticsearchRepository<Book,Integer> {
}
```

```java
@SpringBootTest
class Springboot03ElasticApplicationTests {

    @Autowired
    JestClient jestClient;

    @Autowired
    BookRepository bookRepository;

    @Test
    public void test02(){
        Book book = new Book();
        book.setId(1);
        book.setBookName("西游记");
        book.setAuthor("吴承恩");
        bookRepository.index(book);
    }
}
```



# 四、SpringBoot与任务

## 1、异步任务

```java
@EnableAsync        //开启异步注解功能
@SpringBootApplication
public class Springboot04TaskApplication {

    public static void main(String[] args) {
        SpringApplication.run(Springboot04TaskApplication.class, args);
    }
}
```

```java
@Service
public class AsyncService {

    @Async		//告诉Spring这是一个异步方法
    public void hello(){
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("处理数据中...");
    }
}
```

```java
@RestController
public class AsyncController {

    @Autowired
    AsyncService asyncService;

    @GetMapping("/hello")
    public String hello(){
        asyncService.hello();
        return "success";
    }
}
```

同步：控制台在3秒后显示处理数据中...，然后页面跳转显示success

异步：页面会先相应success，控制台在3秒后显示处理数据中...



## 2、定时任务

**简介：**

	项目开发中经常需要执行一些定时任务，比如需要在每天凌晨时候，分析一次前一天的日志信息。Spring为我们提供了异步执行任务调度的方式，提供 TaskExecutor、TaskSchedule 接口



### 1、静态：基于注解（重点）

**两个注解：** @EnableScheduling、@Scheduled

**cron表达式：**

| 字段 | 允许值                | 允许的特殊字符  |
| ---- | --------------------- | --------------- |
| 秒   | 0-59                  | , - * /         |
| 分   | 0-59                  | , - * /         |
| 小时 | 0-23                  | , - * /         |
| 日期 | 1-31                  | , - * ? / L W C |
| 月份 | 1-12                  | , - * /         |
| 星期 | 0-7或SUN-SAT 0,7是SUN | , - * ? / L C # |

| 特殊字符 | 代表含义                     |
| -------- | ---------------------------- |
| ,        | 枚举                         |
| -        | 区间                         |
| *        | 任意                         |
| /        | 步长                         |
| ?        | 日/星期冲突匹配              |
| L        | 最后                         |
| W        | 工作日                       |
| C        | 和 calendar 联系后计算过的值 |
| #        | 星期，4#2，第2个星期四       |

基于注解@Scheduled默认为单线程，开启多个任务时，任务的执行时机会受上一个任务执行时间的影响。

```java
@EnableScheduling       //开启定时任务
@SpringBootApplication
public class TimingTaskApplication {

    public static void main(String[] args) {
        SpringApplication.run(TimingTaskApplication.class, args);
    }

}
```

```java
@Configuration
public class StaticScheduleTask {

    //添加定时任务
    @Scheduled(cron = "0/3 * * * * *")
	//或直接指定时间间隔，例如：5秒
    //@Scheduled(fixedRate = 5000)
    private void configureTasks() {
        System.out.println("执行静态定时任务时间：" + LocalDateTime.now());
    }
}
```

【启动测试】

![](F:\Typora\images\20181220161509852.png)



### 2、动态：基于接口

实际使用中我们往往想从数据库中读取指定时间来动态执行定时任务，这时候基于接口的定时任务就派上用场了。

【导入依赖】

```xml
<dependencies>
    <dependency><!--添加Web依赖 -->
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency><!--添加MySql依赖 -->
         <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
    </dependency>
    <dependency><!--添加Mybatis依赖 配置mybatis的一些初始化的东西-->
        <groupId>org.mybatis.spring.boot</groupId>
        <artifactId>mybatis-spring-boot-starter</artifactId>
        <version>1.3.1</version>
    </dependency>
    <dependency><!-- 添加mybatis依赖 -->
        <groupId>org.mybatis</groupId>
        <artifactId>mybatis</artifactId>
        <version>3.4.5</version>
        <scope>compile</scope>
    </dependency>
</dependencies>
```

【添加数据库信息】

![image-20200417134039616](F:\Typora\images\image-20200417134039616.png)

```yaml
spring:
  datasource:
    username: root
    password: 1015
    url: jdbc:mysql://localhost:3306/timing?useUnicode=true&characterEncoding=utf-8&serverTimezone=UTC
```

【创建定时器】

```java
@Configuration
public class DynamicScheduleTask implements SchedulingConfigurer {

    @Mapper
    public interface CronMapper {
        @Select("select cron from cron limit 1")
        public String getCron();
    }

    @Autowired
    @SuppressWarnings("all")
    CronMapper cronMapper;

    /**
     * 执行定时任务
     */
    @Override
    public void configureTasks(ScheduledTaskRegistrar taskRegistrar) {
        taskRegistrar.addTriggerTask(
                //1、添加任务内容(Runnable)
                () -> System.out.println("执行动态定时任务：" + LocalDateTime.now().toLocalTime()),
                //设置执行周期(Trigger)
                triggerContext -> {
                    //从数据库获取执行周期
                    String cron = cronMapper.getCron();
                    //合法性校验
                    if (StringUtils.isEmpty(cron)) {
                        // Omitted Code
                    }
                    //返回执行周期（Date）
                    return new CronTrigger(cron).nextExecutionTime(triggerContext);
                }
        );
    }
}
```

【启动测试】

![](F:\Typora\images\20181220161739406.png)



### 3、多线程定时任务

```java
@EnableScheduling       //开启定时任务
@EnableAsync            //开启多线程
@SpringBootApplication
public class TimingTaskApplication {

    public static void main(String[] args) {
        SpringApplication.run(TimingTaskApplication.class, args);
    }
}
```

```java
@Component
public class MultithreadScheduleTask {

    @Async
    @Scheduled(fixedDelay = 1000)   //间隔1秒
    public void firest() throws InterruptedException {
        System.out.println("第一个定时任务开始 : " + LocalDateTime.now().toLocalTime() + "\r\n线程 : " + Thread.currentThread().getName());
        System.out.println();
        Thread.sleep(1000*10);
    }

    @Async
    @Scheduled(fixedDelay = 2000)
    public void second(){
        System.out.println("第二个定时任务开始 : " + LocalDateTime.now().toLocalTime() + "\r\n线程 : " + Thread.currentThread().getName());
        System.out.println();
    }
}
```

![å¨è¿éæå¥å¾çæè¿°](F:\Typora\images\20181220165535820.png)

从控制台可以看出，第一个定时任务和第二个定时任务互不影响。而且，开启了多线程，第一个任务的执行时间也不受其本身执行时间的限制，所以需要注意可能会出现重复执行操作导致数据异常。



## 3、邮件任务

- 邮件附送需要引入 spring-boot-starter-mail
- Spring Boot自动配置 MailSenderAutoConfiguration
- 定义MailProperties内容，配置在 application.yaml中
- 自动装配 JavaMailSender
- 测试邮件发送

```properties
spring.mail.username=576779239@qq.com
# 授权码
spring.mail.password=rkbsmkhtakmpbecg
spring.mail.host=smtp.qq.com
### 若是报ssl异常，则需要以下配置
# spring.mail.properties.mail.smtp.ssl.enable=true
```

![image-20200129194632978](F:\Typora\images\image-20200129194632978.png)

### 1、简单邮件

```java
@SpringBootTest
class Springboot04TaskApplicationTests {

    @Autowired
    JavaMailSenderImpl mailSender;
    //MailSenderAutoConfiguration类导入MailSenderJndiConfiguration类中的组件

    @Test
    void contextLoads() {
        SimpleMailMessage message = new SimpleMailMessage();
        //邮件通知
        message.setSubject("通知-今晚开会");
        message.setText("今晚7:30开会");

        message.setTo("cyy576779239@163.com");
        message.setFrom("576779239@qq.com");

        mailSender.send(message);
    }
}
```

![image-20200129194941099](F:\Typora\images\image-20200129194941099.png)

### 2、复杂邮件

```java
@SpringBootTest
class Springboot04TaskApplicationTests {

    @Autowired
    JavaMailSenderImpl mailSender;

    @Test
    public void test02() throws MessagingException {
        //1、创建一个复杂的消息邮件
        MimeMessage mimeMessage = mailSender.createMimeMessage();
        MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true);

        //邮件通知
        helper.setSubject("通知-今晚开会");
        helper.setText("<b style='color:red'>今晚8:00开会</b>",true);

        helper.setTo("cyy576779239@163.com");
        helper.setFrom("576779239@qq.com");

        //上传文件
        helper.addAttachment("1.jpg",new File("C:\\Users\\Dell\\Pictures\\Saved Pictures\\10.jpg"));
        helper.addAttachment("2.jpg",new File("C:\\Users\\Dell\\Pictures\\Saved Pictures\\9.png"));

        mailSender.send(mimeMessage);
    }
}

```



# 五、SpringBoot与安全

**简介：**

Spring Security 是针对Spring项目的安全框架，也是SpringBoot底层安全默认的技术选项。他可以实现强大的web安全控制。对于安全控制，我们仅需引入 spring-boot-starter-security 模块，进行少量的配置，即可实现强大的安全管理。



应用程序的两个主要区域是“认证”和“授权”(或者访问控制)，这两个主要区域是 Spring Security 的两个目标。

- “认证”（Authentication），是建立一个它声明的主体的过程（一个“主体”一般是指用户，设备或一些可以在你的应用程序中执行动作的其他系统）
- “授权”（Authorization）指确定一个主体是否允许在你的应用程序执行一个动作的过程。为了抵达需要授权的店，主体的身份已经有认证过程建立
- 这个概念是通用的而不止在 Spring Security 中



## 1、引入SpringSecurity模块

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
```

## 2、控制请求的访问去向

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20200130133944875.png" alt="image-20200130133944875" style="zoom:80%;" />

```java
@Controller
public class KungfuController {

    private final String PREFIX = "pages/";
    
    /**
     * 欢迎页
     * @return
     */
    @GetMapping("/")
    public String index(){
        return "welcome";
    }

    /**
     * 登录页
     * @return
     */
    @GetMapping("/login")
    public String loginPage(){
        return PREFIX + "login";
    }

    /**
     * level1页面映射
     * @param path
     * @return
     */
    @GetMapping("/level1/{path}")
    public String level1(@PathVariable("path") String path){
        return PREFIX + "level1/" + path;
    }

    /**
     * level2页面映射
     * @param path
     * @return
     */
    @GetMapping("/level2/{path}")
    public String level2(@PathVariable("path")String path) {
        return PREFIX+"level2/"+path;
    }

    /**
     * level3页面映射
     * @param path
     * @return
     */
    @GetMapping("/level3/{path}")
    public String level3(@PathVariable("path")String path) {
        return PREFIX+"level3/"+path;
    }
}
```

## 3、编写 SpringSecurity 的配置类

需要继承 WebSecurityConfigurerAdapter

###1、设置文件权限

```java
@EnableWebSecurity  //含有@Configuration
public class MySecurityConfig extends WebSecurityConfigurerAdapter {
   
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        //订制请求的授权规则
        http.authorizeRequests().antMatchers("/").permitAll()
                .antMatchers("/level1/**").hasRole("VIP1")
                .antMatchers("/level2/**").hasRole("VIP2")
                .antMatchers("/level3/**").hasRole("VIP3");

        //开启自动配置的登录功能，效果，没有权限就会跳转到登录页面
        http.formLogin();
        /**
         * 1、/login来到登录页
         * 2、重定向到 /login?error
         * 3、更多详细规定
         */
    }

}
```

### 2、用户权限

```java
@EnableWebSecurity  //含有@Configuration
public class MySecurityConfig extends WebSecurityConfigurerAdapter {
   
    //定义认证规则
    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {

        auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())
                .withUser("zhangsan").password(new BCryptPasswordEncoder().encode("12345")).roles("VIP1","VIP2")
                .and()
                .withUser("lisi").password(new BCryptPasswordEncoder().encode("12345")).roles("VIP2","VIP3")
                .and()
                .withUser("wangwu").password(new BCryptPasswordEncoder().encode("12345")).roles("VIP1","VIP3");

    }

}
```

### 3、注销功能

清空session中的用户信息

```java
@EnableWebSecurity  //含有@Configuration
public class MySecurityConfig extends WebSecurityConfigurerAdapter {

	//开启自动配置的注销功能
    http.logout().logoutSuccessUrl("/");//注销成功以后来到首页
    //1、访问 /logout 表示用户注销，清空session
    //2、注销成功会返回 /login?logout页面
}
```

### 4、设置不同权限显示内容

```html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org"
      xmlns:sec="http://www.thymeleaf.org/thymeleaf-extras-springsecurity5">
    
<div sec:authorize="!isAuthenticated()">
    <h2 align="center">游客您好，如果想查看武林秘籍 <a th:href="@{/login}">请登录</a></h2>
</div>
<div sec:authorize="isAuthenticated()">
    <h2><span sec:authentication="name"></span>,你好，你的角色有，
        <span sec:authentication="principal.authorities"></span></h2>
    <form th:action="@{/logout}" th:method="post">
        <input type="submit" value="注销">
    </form>
</div>
    
<div sec:authorize="hasRole('VIP1')">
    <h3>普通武功秘籍</h3>
    <ul>
        <li><a th:href="@{/level1/1}">罗汉拳</a></li>
        <li><a th:href="@{/level1/2}">武当长拳</a></li>
        <li><a th:href="@{/level1/3}">全真剑法</a></li>
    </ul>
</div>

<div sec:authorize="hasRole('VIP2')">
    <h3>高级武功秘籍</h3>
    <ul>
        <li><a th:href="@{/level2/1}">太极拳</a></li>
        <li><a th:href="@{/level2/2}">七伤拳</a></li>
        <li><a th:href="@{/level2/3}">梯云纵</a></li>
    </ul>
</div>
```

### 5、订制登录页面

SpringSecurity 可以使用默认的登录页面，也支持订制页面

#### 1、实现订制功能

```java
@EnableWebSecurity  //含有@Configuration
public class MySecurityConfig extends WebSecurityConfigurerAdapter {

	//开启自动配置的登录功能，效果，没有权限就会跳转到登录页面
  	http.formLogin().usernameParameter("user").passwordParameter("pwd") .loginPage("/userlogin");
        /**
         * 1、/login来到登录页
         * 2、重定向到 /login?error
         * 3、更多详细规定
         * 4、默认post形式的 /login 代表处理登录
         * 5、一旦订制loginPage，那么loginPage的post请求就是登录
         */
}
```

```java
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
	<h1 align="center">欢迎登陆武林秘籍管理系统</h1>
	<hr>
	<div align="center">
		<form th:action="@{/userlogin}" method="post">
			用户名:<input name="user"/><br>
			密码:<input name="pwd"><br/>
			<input type="checkbox" name="remember"> 记住我 <br/>
			<input type="submit" value="登陆">
		</form>
	</div>
</body>
</html>
```

#### 2、实现记住用户功能

```java
@EnableWebSecurity  //含有@Configuration
public class MySecurityConfig extends WebSecurityConfigurerAdapter {

	//开启记住我功能
    http.rememberMe().rememberMeParameter("remember");
    //登录成功以后，将cookie发给浏览器保存，以后访问页面带上这个cookie，只要通过检查就可以免登陆
    //点击注销会删除cookie
}
```

```html
<!-- name需要对应相同 -->
<input type="checkbox" name="remember"> 记住我 <br/>
```



# 六、SpringBoot 与分布式

## 一、分布式应用

在分布式系统中，国内常用 zookeeper+dubbo组合，而SpringBoot推荐使用全栈的Spring、SpringBoot + Spring Cloud。

![image-20200130173836604](F:\Typora\images\image-20200130173836604.png)

## 二、SpringBoot、Zookeeper和Dubbo整合

### 1、Zookeeper

Zookeeper 是一个分布式的，开发源码的分布式应用程序协调服务。他是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。

```shell
[root@localhost ~]# docker pull zookeeper
[root@localhost ~]# docker run --name zookeeper01 -p 2181:2181 --restart always -d zookeeper
```

### 2、Dubbo

Dubbo是Alibaba开源的分布式服务框架，它最大的特点是按照分层的方式来架构，使用这种方式可以是各个层解耦合（或者最大限度地松耦合）。从服务模型的角度来看，Dubbo采用的是一种非常简单的模型，要么是提供方提供服务，要么是消费方消费服务，所以基于这一点可以抽象出服务提供方（Provider）和服务消费方（Consumer）两个角色。

![image-20200130174916626](F:\Typora\images\image-20200130174916626.png)

### 3、代码实现

**新建两个项目，一个作为生产者，一个作为消费者。**

#### 1、生产者

将服务提供者注册到注册中心

1. 它引入dubbo和zkclient相关依赖
1. 配置dubbo的扫描包和注册中心地址
1. 使用@Service发布服务

**项目结构：**

![image-20200131150048572](F:\Typora\images\image-20200131150048572.png)

```xml
<dependency>
    <groupId>com.alibaba.boot</groupId>
    <artifactId>dubbo-spring-boot-starter</artifactId>
    <version>0.1.0</version>
</dependency>

<!--引入zookeeper的客户端工具-->
<!-- https://mvnrepository.com/artifact/com.github.sgroschupf/zkclient -->
<dependency>
    <groupId>com.github.sgroschupf</groupId>
    <artifactId>zkclient</artifactId>
    <version>0.1</version>
</dependency>
```

**配置文件：**

```properties
dubbo.application.name=provider-ticket

dubbo.registry.address=zookeeper://192.168.248.128:2181

dubbo.scan.base-packages=com.atguigu.ticket.service
```

```java
package com.atguigu.ticket.service;

public interface TicketService {

    public String getTicket();
}
```

```java
package com.atguigu.ticket.service;

import com.alibaba.dubbo.config.annotation.Service;
import com.alibaba.dubbo.config.spring.context.annotation.EnableDubbo;
import org.springframework.stereotype.Component;

@EnableDubbo
@Component
@Service    //将服务发布出去
public class TicketServiceImpl implements TicketService {
    @Override
    public String getTicket() {
        return "《厉害了，我的国》";
    }
}
```

#### 2、消费者

1. 引入依赖
1. 配置dubbo的注册中心地址
1. 引入服务

![image-20200131150435895](F:\Typora\images\image-20200131150435895.png)

注：接口目录结构需要相同

```xml
<dependency>
    <groupId>com.alibaba.boot</groupId>
    <artifactId>dubbo-spring-boot-starter</artifactId>
    <version>0.1.0</version>
</dependency>

<!--引入zookeeper的客户端工具-->
<!-- https://mvnrepository.com/artifact/com.github.sgroschupf/zkclient -->
<dependency>
    <groupId>com.github.sgroschupf</groupId>
    <artifactId>zkclient</artifactId>
    <version>0.1</version>
</dependency>
```

```properties
dubbo.application.name=consumer-user

dubbo.registry.address=zookeeper://192.168.248.128:2181

server.port=8081
```

```java
package com.atguigu.ticket.service;

public interface TicketService {
    public String getTicket();
}
```

```java
package com.atguigu.user.service;

import com.alibaba.dubbo.config.annotation.Reference;
import com.atguigu.ticket.service.TicketService;
import org.springframework.stereotype.Service;

@Service
public class UserService {

    @Reference
    TicketService ticketService;

    public void hello(){
        String ticket = ticketService.getTicket();
        System.out.println("买到票了"+ticket);
    }
}
```

**测试类：**

```java
@SpringBootTest
class ConsumerUserApplicationTests {

    @Autowired
    UserService userService;

    @Test
    void contextLoads() {
        userService.hello();
    }
}
```

开启生产者 服务器，开启测试类：

![image-20200131150934829](F:\Typora\images\image-20200131150934829.png)

## 三、SpringBoot和SpringCloud

### 1、SpringCloud-Eureka注册中心

#### 1、填写模块

![image-20200201095603278](F:\Typora\images\image-20200201095603278.png)

```xml
<!-- 加入的依赖 -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
</dependency>
```

#### 2、配置Eureka信息

```yaml
server:
  port: 8761
eureka:
  instance:
    hostname: eureka-server   # eureka实例的主机名
  client:
    register-with-eureka: false   # 不把自己注册到eureka上
    fetch-registry: false         # 不从eureka上来获取服务的注册信息
    service-url:
      defaultZone: http://localhost:8761/eureka
```

#### 3、开启Eureka服务

```java
@EnableEurekaServer
@SpringBootApplication
public class EurekaServerApplication {

    public static void main(String[] args) {
        SpringApplication.run(EurekaServerApplication.class, args);
    }
}
```

#### 4、验证成功

![image-20200201095847624](F:\Typora\images\image-20200201095847624.png)



### 2、生产者

#### 1、填写模块

![image-20200201104651424](F:\Typora\images\image-20200201104651424.png)

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>
```

#### 2、配置文件信息

```yaml
server:
  port: 8082
spring:
  application:
    name: provider-ticket
eureka:
  instance:
    prefer-ip-address: true   # 注册服务的时候使用服务的ip地址
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka
```

#### 3、测试代码

```java
package com.atguigu.providerticket.service;

import org.springframework.stereotype.Service;

@Service
public class TicketService {

    public String getTicket(){
        return "<厉害了，我的国>";
    }
}
```

```java
package com.atguigu.providerticket.controller;

import com.atguigu.providerticket.service.TicketService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class TicketController {

    @Autowired
    TicketService ticketService;

    @GetMapping("/ticket")
    public String getTicket(){
        return ticketService.getTicket();
    }
}

```

测试效果：

![image-20200201105050632](F:\Typora\images\image-20200201105050632.png)

也可以一个应用开启多个实例：

![image-20200201105143086](F:\Typora\images\image-20200201105143086.png)



### 3、消费者

#### 1、填写模块

![image-20200201104651424](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20200201104651424.png)

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>
```

#### 2、配置文件信息

```yaml
spring:
  application:
    name: consumer-user
server:
  port: 8200

eureka:
  instance:
    prefer-ip-address: true   # 注册服务的时候使用服务的ip地址
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka
```

### 3、代码实现

```java
@EnableDiscoveryClient      //开启发现服务功能
@SpringBootApplication
public class ConsumerUserApplication {

    public static void main(String[] args) {
        SpringApplication.run(ConsumerUserApplication.class, args);
    }

    @LoadBalanced   //使用负载均衡机制
    @Bean
    public static RestTemplate restTemplate(){
        return new RestTemplate();
    }
}
```

```java
@RestController
public class UserController {

    @Autowired
    RestTemplate restTemplate = ConsumerUserApplication.restTemplate();

    @GetMapping("/buy")
    public String buyTicket(String name){
        String s = restTemplate.getForObject("http://PROVIDER-TICKET/ticket", String.class);
        return name+"购买了"+s;
    }
}
```

![image-20200201134922042](F:\Typora\images\image-20200201134922042.png)





# 七、SpringBoot与开发热部署

## 1、热部署

在开发中我们修改一个Java文件后想看到效果不得不重启应用，这导致大量时间花费，我们希望不重启应用的情况下，程序可以自动部署（热部署）。有以下四种情况，能实现热部署



### 1、模板引擎

- 在SpringBoot中开发情况下禁用模板引擎的cache

- 页面模板改变 ctrl+F9 可以重新编译当前页面并生效

### 2、Spring Loaded

Spring官方提供的热部署程序，实现修改类文件的热部署

- 下载 Spring Loaded（项目地址：htpps://github.com/spring-projects/spring-loaded）
- 添加运行时参数：
  - javaagent: C:/springloaded-1.2.5.RELEASE.jar -noverify

### 3、JRebel

- 收费的一个热部署软件
- 安装插件使用即可

### 4、Spring Boot Devtools（推荐）

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-devtools</artifactId>
</dependency>
```



### 5、代码实现

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-devtools</artifactId>
    <optional>true</optional>
</dependency>
```

```java
@Controller
public class HelloController {
    public HelloController() {
    }

    @GetMapping({"/hello"})
    public String hello() {
        return "hello";
    }
}
```

代码修改之后IDEA中只需要按 Ctrl+F9 即可再次编译，eclipse中需要 ctrl+s



# 八、SpringBoot与监控管理

## 1、监控管理

通过引入 spring-boot-starter-actuator，可以使用SpringBoot为我们提供的准生产环境下的应用监控和管理功能。我们可以通过HTTP、JMX、SSH协议来进行操作，自动得到审计、健康及指标信息等。

**步骤：**

- 引入 spring-boot-starter-autuator
- 通过http方式访问监控端点
- 可进行 shutdown（POSt提交，此端点默认关闭）









# 九、复习

狂神



## 1、任务

### 1、异步任务

[项目](E:\workspace\workspace-springboot\2\springboot-09-kuang\springboot-01-test)

Service 层中编写方法

```java
@Service
public class AsyncService {

    //告诉SpringBoot这是一个异步任务
    @Async
    public void hello(){
        try {
            Thread.sleep(3000);
            System.out.println("数据正在处理");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

```java
@RestController
public class AsyncController {

    @Autowired
    private AsyncService service;

    @RequestMapping("/hello")
    public String hello(){
        service.hello();
        return "ok";
    }
}
```

开启异步任务

```java
@EnableAsync    //开启异步任务
@SpringBootApplication
public class Springboot01TestApplication {

    public static void main(String[] args) {
        SpringApplication.run(Springboot01TestApplication.class, args);
    }
}
```